 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>OGforge</title>
    <style>
        :root{
            --bg-0:#07070a;
            --bg-1:#0c0c12;
            --panel:rgba(18,18,26,.72);
            --panel-strong:rgba(18,18,26,.9);
            --border:rgba(255,255,255,.10);
            --text:#eef0ff;
            --muted:rgba(238,240,255,.72);
            --accent:#ff4d6d;
            --accent-2:#7c5cff;
            --good:#32d583;
            --warn:#ffb020;
            --cyan:#39e6ff;
            --radius-sm: 10px;
            --radius-md: 14px;
            --radius-lg: 18px;
        }

        body {
            margin: 0;
            overflow: hidden;
            background:
                radial-gradient(1200px 900px at 65% 35%, rgba(124,92,255,.18), transparent 55%),
                radial-gradient(1000px 800px at 30% 70%, rgba(255,77,109,.12), transparent 60%),
                linear-gradient(180deg, var(--bg-0), var(--bg-1));
            color: var(--text);
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
            touch-action: none; /* Prevent zoom/scroll on mobile */
        }

        #gameCanvas {
            display: block;
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 14px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.55), transparent);
            gap: 12px;
            flex-wrap: wrap;
            align-items: flex-start;
        }

        .stats-box {
            background: linear-gradient(180deg, rgba(24,24,36,.80), rgba(16,16,24,.65));
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            padding: 10px 14px;
            pointer-events: auto;
            min-width: 120px;
            backdrop-filter: blur(10px);
            box-shadow:
                0 10px 30px rgba(0,0,0,.35),
                inset 0 1px 0 rgba(255,255,255,.08);
        }

        .stat-row {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 13px;
            font-weight: 700;
            letter-spacing: .2px;
        }

        .stat-row img, .stat-icon {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            display: inline-block;
            border-radius: 50%;
            box-shadow: 0 0 0 1px rgba(255,255,255,.12), 0 6px 18px rgba(0,0,0,.35);
        }

        .money { color: var(--good); }
        .ore-coal { color: rgba(238,240,255,.78); }
        .ore-iron { color: #ffb86c; }
        .ore-gold { color: #ffd56a; }
        .ore-diamond { color: var(--cyan); }

        .xp-box{
            flex: 1 1 auto;
            min-width: 160px;
            max-width: 420px;
            align-self: flex-start;
            background: linear-gradient(180deg, rgba(32,24,12,.88), rgba(16,12,8,.78));
            border: 1px solid rgba(255,205,110,.28);
            border-radius: var(--radius-md);
            padding: 10px 14px 12px;
            box-shadow: 0 16px 36px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.10);
            pointer-events: none;
            position: relative;
            overflow: hidden;
        }
        .xp-box::after{
            content:"";
            position:absolute;
            inset: 1px;
            border-radius: calc(var(--radius-md) - 1px);
            border: 1px solid rgba(255,255,255,.06);
            pointer-events:none;
        }
        .xp-label{
            display:flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 10px;
            font-size: 11px;
            letter-spacing: .8px;
            text-transform: uppercase;
            font-weight: 800;
            color: rgba(255,232,170,.92);
        }
        .xp-label .xp-value{
            font-size: 10px;
            color: rgba(255,236,190,.78);
        }
        .xp-track{
            position: relative;
            height: 12px;
            margin-top: 8px;
            border-radius: 999px;
            background: linear-gradient(180deg, rgba(0,0,0,.6), rgba(0,0,0,.35));
            box-shadow: inset 0 0 0 1px rgba(255,255,255,.08), inset 0 6px 12px rgba(0,0,0,.45);
            overflow: hidden;
        }
        .xp-fill{
            height: 100%;
            width: 0%;
            border-radius: inherit;
            background: linear-gradient(90deg, rgba(255,205,90,.95), rgba(255,176,32,.98), rgba(255,220,140,.95));
            box-shadow: 0 0 18px rgba(255,176,32,.55), inset 0 0 8px rgba(255,255,255,.25);
            transition: width .25s ease-out;
        }
        .xp-sheen{
            position:absolute;
            inset: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,.45) 50%, transparent 100%);
            transform: translateX(-120%);
            animation: xp-sheen 3.8s ease-in-out infinite;
            mix-blend-mode: screen;
            opacity: 0.6;
        }
        @keyframes xp-sheen{
            0%{ transform: translateX(-120%); }
            55%{ transform: translateX(120%); }
            100%{ transform: translateX(120%); }
        }

        .stats-ores{
            min-width: 150px;
        }
        .ore-header{
            display:flex;
            align-items:center;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 6px;
        }
        .ore-title{
            font-size: 11px;
            letter-spacing: .8px;
            text-transform: uppercase;
            font-weight: 800;
            color: rgba(238,240,255,.8);
        }
        .ore-actions{
            display:flex;
            gap: 6px;
        }
        .ore-toggle,
        .ore-filter-btn{
            appearance: none;
            border: 1px solid rgba(255,255,255,.15);
            background: rgba(255,255,255,.06);
            color: rgba(238,240,255,.9);
            font-size: 10px;
            letter-spacing: .5px;
            padding: 4px 8px;
            border-radius: 999px;
            cursor: pointer;
            font-weight: 800;
        }
        .ore-list{
            display:flex;
            flex-direction: column;
            gap: 6px;
        }
        .ore-row{
            display:flex;
            align-items:center;
            justify-content: space-between;
            font-size: 12px;
            font-weight: 700;
        }
        .ore-left{
            display:flex;
            align-items:center;
            gap: 6px;
        }
        .ore-count{
            font-variant-numeric: tabular-nums;
        }
        .ore-filter{
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255,255,255,.08);
        }
        .ore-filter-grid{
            display:grid;
            grid-template-columns: repeat(2, minmax(0,1fr));
            gap: 6px 10px;
            margin-top: 6px;
        }
        .ore-filter-item{
            display:flex;
            align-items:center;
            gap: 6px;
            font-size: 11px;
            color: rgba(238,240,255,.8);
        }
        .ore-filter-item input{
            accent-color: #ffd56a;
        }
        .ore-filter-actions{
            display:flex;
            gap: 8px;
            margin-top: 8px;
        }
        .ore-filter-actions button{
            appearance: none;
            border: 1px solid rgba(255,255,255,.16);
            background: rgba(255,255,255,.06);
            color: rgba(238,240,255,.85);
            font-size: 10px;
            letter-spacing: .5px;
            padding: 4px 8px;
            border-radius: 999px;
            cursor: pointer;
            font-weight: 800;
        }
        .stats-ores[data-collapsed="true"] .ore-list,
        .stats-ores[data-collapsed="true"] .ore-filter{
            display:none;
        }

        #forge-menu, #esc-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(180deg, rgba(22,22,34,.92), rgba(14,14,22,.92));
            border: 1px solid rgba(255,77,109,.45);
            border-radius: var(--radius-lg);
            padding: 0;
            width: 90%;
            max-width: 460px;
            text-align: center;
            display: none; /* Hidden by default */
            pointer-events: auto;
            box-shadow:
                0 28px 70px rgba(0,0,0,0.65),
                inset 0 1px 0 rgba(255,255,255,0.08);
            backdrop-filter: blur(10px);
        }

        #esc-menu{
            border-color: rgba(124,92,255,.40);
        }

        .forge-header{
            padding: 18px 18px 10px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,.10);
            background:
                radial-gradient(800px 250px at 20% 0%, rgba(124,92,255,.18), transparent 60%),
                radial-gradient(800px 250px at 90% 30%, rgba(255,77,109,.12), transparent 60%),
                linear-gradient(180deg, rgba(24,24,36,.72), rgba(14,14,22,.70));
            border-top-left-radius: var(--radius-lg);
            border-top-right-radius: var(--radius-lg);
        }
        .forge-title{
            display:flex;
            align-items:baseline;
            justify-content:space-between;
            gap: 10px;
        }
        .forge-title h2{
            margin: 0;
            color: rgba(255,255,255,.95);
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
            font-size: 16px;
            letter-spacing: .9px;
            text-transform: uppercase;
        }
        .forge-title .mine-label{
            font-size: 12px;
            font-weight: 750;
            color: rgba(238,240,255,.75);
            background: rgba(255,255,255,.06);
            border: 1px solid rgba(255,255,255,.10);
            border-radius: 999px;
            padding: 6px 10px;
            box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
            white-space: nowrap;
        }
        .forge-sub{
            margin: 8px 0 10px;
            color: rgba(238,240,255,.75);
            font-size: 13px;
            line-height: 1.45;
        }
        .forge-tabs{
            display:flex;
            gap: 8px;
            padding: 10px 0 0;
            overflow:auto;
            -webkit-overflow-scrolling: touch;
        }
        .forge-tab{
            pointer-events: auto;
            border: 1px solid rgba(255,255,255,.10);
            background: rgba(255,255,255,.05);
            color: rgba(238,240,255,.85);
            border-radius: 999px;
            padding: 8px 12px;
            font-weight: 800;
            letter-spacing: .2px;
            font-size: 12px;
            cursor: pointer;
            user-select: none;
            transition: transform .15s, background .15s, border-color .15s;
        }
        .forge-tab:hover{ border-color: rgba(255,255,255,.18); transform: translateY(-1px); }
        .forge-tab:active{ transform: translateY(0px) scale(.99); }
        .forge-tab.active{
            background: linear-gradient(180deg, rgba(255,77,109,.95), rgba(255,77,109,.78));
            border-color: rgba(255,77,109,.55);
            color: rgba(255,255,255,.95);
            box-shadow: 0 10px 28px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.12);
        }
        .forge-body{
            padding: 14px 18px 6px;
            max-height: min(64vh, 540px);
            overflow: auto;
            text-align: left;
            -webkit-overflow-scrolling: touch;
        }
        .forge-panel{
            background: rgba(255,255,255,.03);
            border: 1px solid rgba(255,255,255,.08);
            border-radius: var(--radius-md);
            padding: 12px 12px;
            box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
        }
        .forge-grid-2{
            display:grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .forge-kicker{
            font-size: 11px;
            letter-spacing: .6px;
            text-transform: uppercase;
            color: rgba(238,240,255,.65);
            margin-bottom: 6px;
            font-weight: 800;
        }
        .forge-muted{
            font-size: 11px;
            color: rgba(238,240,255,.55);
        }
        .forge-sep{
            border: 0;
            height: 1px;
            background: rgba(255,255,255,.12);
            opacity: .9;
            margin: 14px 0;
        }
        .forge-tab-panel{ display:none; }
        .forge-tab-panel.active{ display:block; }

        .mine-list{
            display:flex;
            flex-direction: column;
            gap: 10px;
        }
        .mine-item{
            display:flex;
            align-items:center;
            justify-content:space-between;
            gap: 10px;
            padding: 12px;
            border-radius: var(--radius-md);
            border: 1px solid rgba(255,255,255,.10);
            background: rgba(0,0,0,.18);
        }
        .mine-item .name{
            font-weight: 850;
            letter-spacing: .2px;
        }
        .mine-item .meta{
            font-size: 11px;
            color: rgba(238,240,255,.60);
            margin-top: 2px;
        }
        .mine-item .mine-actions{
            display:flex;
            gap: 8px;
            flex-shrink: 0;
        }
        .btn-mini{
            padding: 8px 10px;
            border-radius: 999px;
            width: auto;
            text-align: center;
            justify-content: center;
            font-size: 12px;
        }
        .btn-mini.primary{
            background: linear-gradient(180deg, rgba(124,92,255,.95), rgba(124,92,255,.78));
            border-color: rgba(124,92,255,.55);
        }

        .input{
            width: 100%;
            box-sizing: border-box;
            background: rgba(255,255,255,.06);
            border: 1px solid rgba(255,255,255,.10);
            color: rgba(238,240,255,.92);
            border-radius: var(--radius-md);
            padding: 10px 12px;
            outline: none;
            font-weight: 700;
        }
        .input::placeholder{ color: rgba(238,240,255,.40); }
        .input:focus{ border-color: rgba(255,255,255,.18); }

        .forge-footer{
            padding: 10px 18px 16px;
            border-top: 1px solid rgba(255,255,255,.10);
            background: rgba(0,0,0,.12);
            border-bottom-left-radius: var(--radius-lg);
            border-bottom-right-radius: var(--radius-lg);
        }

        .btn {
            background: linear-gradient(180deg, rgba(60,60,80,.85), rgba(40,40,58,.85));
            border: 1px solid rgba(255,255,255,.10);
            color: white;
            padding: 10px 20px;
            margin: 5px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            width: 100%;
            text-align: left;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 12px 26px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.08);
        }

        .btn:hover { transform: translateY(-1px); border-color: rgba(255,255,255,.18); }
        .btn:active { transform: translateY(0px) scale(.99); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-action {
            background: linear-gradient(180deg, rgba(255,77,109,.95), rgba(255,77,109,.78));
            border-color: rgba(255,77,109,.55);
            text-align: center;
            justify-content: center;
        }
        .btn-action:hover { filter: brightness(1.05); }
        .btn-close {
            background: linear-gradient(180deg, rgba(30,30,44,.92), rgba(18,18,28,.92));
            margin-top: 15px;
            text-align: center;
            justify-content: center;
        }

        .code-row{
            display:flex;
            gap: 10px;
            align-items: center;
        }
        .code-row .input{
            flex: 1 1 auto;
        }
        .code-status{
            margin-top: 8px;
            font-size: 12px;
            font-weight: 800;
            letter-spacing: .2px;
            color: rgba(238,240,255,.70);
        }
        .code-status.good{ color: rgba(50,213,131,.95); }
        .code-status.bad{ color: rgba(255,176,32,.95); }

        #message-area {
            position: absolute;
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: auto;
            cursor: pointer;
            font-weight: bold;
            text-shadow: 0 6px 20px rgba(0,0,0,.8);
            font-size: 14px;
            letter-spacing: .4px;
            opacity: 0;
            transition: opacity 0.5s;
            padding: 10px 14px;
            border-radius: 999px;
            background: rgba(10,10,16,.38);
            border: 1px solid rgba(255,255,255,.10);
            backdrop-filter: blur(10px);
        }

        #boot-toast{
            position: absolute;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
            pointer-events: none;
            opacity: 0;
            transition: opacity .45s;
            padding: 10px 14px;
            border-radius: 999px;
            background: rgba(10,10,16,.55);
            border: 1px solid rgba(255,255,255,.12);
            backdrop-filter: blur(10px);
            box-shadow: 0 18px 60px rgba(0,0,0,.55), inset 0 1px 0 rgba(255,255,255,.08);
            color: rgba(238,240,255,.92);
            font-weight: 850;
            letter-spacing: .2px;
            font-size: 13px;
            text-shadow: 0 6px 20px rgba(0,0,0,.8);
        }

        @media (max-width: 520px) {
            .hud-top { padding: 10px; }
            .stats-box { min-width: 0; padding: 8px 10px; border-radius: 12px; }
            .xp-box { width: 100%; min-width: 0; }
            .stats-ores { width: 100%; }
            #forge-menu { width: 94%; }
            .forge-grid-2{ grid-template-columns: 1fr; }
            .forge-header{ padding: 16px 14px 10px; }
            .forge-body{ padding: 12px 14px 6px; max-height: min(66vh, 520px); }
            .forge-footer{ padding: 10px 14px 14px; }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    <div id="boot-toast">You have to play — tap/click to mine. Saves forever.</div>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="stats-box">
                <div class="stat-row money"><span class="stat-icon" style="background:#50fa7b"></span> $<span id="ui-money">0</span></div>
                <div class="stat-row" style="margin-bottom:0;color:rgba(238,240,255,.78)"><span class="stat-icon" style="background:#7c5cff"></span> Depth <span id="ui-depth">0</span></div>
                <div class="stat-row" style="margin-bottom:0;color:rgba(238,240,255,.78)"><span class="stat-icon" style="background:#ffb020"></span> Drills <span id="ui-drills">0</span></div>
            </div>
            <div class="xp-box">
                <div class="xp-label">
                    <span>Level <span id="ui-level">1</span></span>
                    <span class="xp-value"><span id="ui-xp">0</span>/<span id="ui-xp-next">0</span> XP</span>
                </div>
                <div class="xp-track">
                    <div class="xp-fill" id="ui-xp-fill"></div>
                    <div class="xp-sheen"></div>
                </div>
            </div>
            <div class="stats-box stats-ores" id="ore-box" data-collapsed="false">
                <div class="ore-header">
                    <div class="ore-title">Ores</div>
                    <div class="ore-actions">
                        <button class="ore-filter-btn" id="ore-filter-btn" type="button">Filter</button>
                        <button class="ore-toggle" id="ore-toggle" type="button">–</button>
                    </div>
                </div>
                <div id="ore-list" class="ore-list"></div>
                <div id="ore-filter" class="ore-filter" hidden>
                    <div class="ore-title">Display</div>
                    <div class="ore-filter-grid" id="ore-filter-grid"></div>
                    <div class="ore-filter-actions">
                        <button type="button" id="ore-filter-all">All</button>
                        <button type="button" id="ore-filter-none">None</button>
                    </div>
                </div>
            </div>
        </div>
        <div id="message-area" onclick="interactAction()">Press E to interact</div>
    </div>

    <!-- Forge / Shop Menu -->
    <div id="forge-menu">
        <div class="forge-header">
            <div class="forge-title">
                <h2>OGFORGE</h2>
                <div class="mine-label" title="Current mine" id="ui-mine-name">Mine</div>
            </div>
            <div class="forge-sub">Smelt ore, upgrade gear, go deeper.</div>
            <div class="forge-tabs" role="tablist" aria-label="Forge tabs">
                <button class="forge-tab active" data-tab="sell" type="button">Sell</button>
                <button class="forge-tab" data-tab="upgrades" type="button">Upgrades</button>
                <button class="forge-tab" data-tab="tools" type="button">Tools</button>
                <button class="forge-tab" data-tab="codes" type="button">Codes</button>
            </div>
        </div>

        <div class="forge-body">
            <div class="forge-tab-panel active" data-panel="sell" role="tabpanel">
                <button class="btn btn-action" onclick="game.sellAll()"><span>SELL ALL</span><span id="ui-sell-preview">$0</span></button>

                <div style="height:10px"></div>

                <div class="forge-grid-2">
                    <div class="forge-panel">
                        <div class="forge-kicker">Wallet</div>
                        <div style="font-weight:900;font-size:18px;color:#32d583">$<span id="ui-money-menu">0</span></div>
                    </div>
                    <div class="forge-panel">
                        <div class="forge-kicker">Smelter</div>
                        <div style="font-weight:900;font-size:18px;color:rgba(255,255,255,.92)"><span id="ui-smelt-mult">1.00×</span> value</div>
                    </div>
                </div>

                <div style="height:10px"></div>

                <div class="forge-panel">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                        <div class="forge-kicker" style="margin:0">Inventory</div>
                        <div class="forge-muted">Prices shown are base</div>
                    </div>
                    <div id="forge-inventory-list" style="display:grid;grid-template-columns:1fr 1fr;gap:8px;font-size:12px"></div>
                </div>
            </div>

            <div class="forge-tab-panel" data-panel="upgrades" role="tabpanel">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
                    <div class="forge-kicker" style="margin:0">Upgrades</div>
                    <div class="forge-muted">Tap to buy</div>
                </div>

                <button class="btn" id="btn-upg-pick" onclick="game.upgradePickaxe()">
                    <span>Better Pickaxe</span>
                    <span id="cost-pick">$100</span>
                </button>
                <button class="btn" id="btn-upg-boots" onclick="game.upgradeBoots()">
                    <span>Speed Boots</span>
                    <span id="cost-boots">$150</span>
                </button>
                <button class="btn" id="btn-upg-light" onclick="game.upgradeLight()">
                    <span>Stronger Lamp</span>
                    <span id="cost-light">$200</span>
                </button>
                <button class="btn" id="btn-upg-reach" onclick="game.upgradeReach()">
                    <span>Long Reach</span>
                    <span id="cost-reach">$250</span>
                </button>
                <button class="btn" id="btn-upg-smelt" onclick="game.upgradeSmelter()">
                    <span>Smelter Boost</span>
                    <span id="cost-smelt">$400</span>
                </button>
                <button class="btn" id="btn-upg-luck" onclick="game.upgradeLuck()">
                    <span>Lucky Charm</span>
                    <span id="cost-luck">$500</span>
                </button>
                <button class="btn" id="btn-upg-drill" onclick="game.upgradeDrill()">
                    <span>Turbo Drill</span>
                    <span id="cost-drill">$650</span>
                </button>
                <button class="btn" id="btn-upg-xp" onclick="game.upgradeXpBoost()">
                    <span>Scholar's Sigil</span>
                    <span id="cost-xp">$350</span>
                </button>
                <button class="btn" id="btn-upg-crit" onclick="game.upgradeCrit()">
                    <span>Critical Strike</span>
                    <span id="cost-crit">$450</span>
                </button>
                <button class="btn" id="btn-upg-rigcore" onclick="game.upgradeRigCore()">
                    <span>Rig Overclock</span>
                    <span id="cost-rigcore">$550</span>
                </button>
                <button class="btn" id="btn-upg-magnet" onclick="game.upgradeOreMagnet()">
                    <span>Ore Magnet</span>
                    <span id="cost-magnet">$500</span>
                </button>
            </div>

            <div class="forge-tab-panel" data-panel="tools" role="tabpanel">
                <div class="forge-panel" style="margin-bottom: 10px;">
                    <div class="forge-kicker">Drills</div>
                    <div class="forge-muted">Drill rigs mine nearby walls automatically.</div>
                </div>

                <button class="btn" id="btn-buy-rig" onclick="game.buyDrillRig()">
                    <span>Buy Drill Rig</span>
                    <span id="cost-rig">$250</span>
                </button>
                <button class="btn" onclick="game.togglePlaceDrill()">
                    <span>Place Drill (Q)</span>
                    <span style="opacity:.7">Use on walls</span>
                </button>
            </div>

            <div class="forge-tab-panel" data-panel="codes" role="tabpanel">
                <div class="forge-panel">
                    <div class="forge-kicker">Trader Code</div>
                    <div class="forge-muted">Enter a code from the trader.</div>
                    <div style="height:10px"></div>
                    <div class="code-row">
                        <input id="forge-code-input" class="input" type="text" inputmode="text" autocomplete="off" spellcheck="false" placeholder="Enter code" maxlength="32">
                        <button id="forge-code-btn" class="btn-mini primary" type="button" onclick="game.redeemTraderCodeFromUi()">Redeem</button>
                    </div>
                    <div id="forge-code-status" class="code-status">Codes are case-insensitive.</div>
                </div>
            </div>

        </div>

        <div class="forge-footer">
            <button class="btn btn-close" onclick="game.closeForge()">Close</button>
        </div>
    </div>

    <!-- ESC Mines Menu -->
    <div id="esc-menu" aria-hidden="true">
        <div class="forge-header">
            <div class="forge-title">
                <h2>MINES</h2>
                <div class="mine-label" title="Current mine" id="esc-mine-name">Mine</div>
            </div>
            <div class="forge-sub">Switch mines, rename them, and keep progress separate.</div>
        </div>

        <div class="forge-body">
            <div class="forge-panel" style="margin-bottom: 10px;">
                <div class="forge-kicker">Your Mines</div>
                <div class="forge-muted" id="esc-save-path">Saves on this computer.</div>
            </div>

            <div class="mine-list" id="esc-mines-list"></div>

            <div style="height:10px"></div>

            <div class="forge-panel">
                <div class="forge-kicker">Create Mine</div>
                <input id="esc-new-mine-name" class="input" type="text" maxlength="24" placeholder="Name (optional)">
                <div style="height:8px"></div>
                <button class="btn btn-action" type="button" onclick="createNewMine()">CREATE & SWITCH</button>
            </div>
        </div>

        <div class="forge-footer">
            <button class="btn btn-close" type="button" onclick="MinesUi.close()">Close (ESC)</button>
        </div>
    </div>

<script>
/**
 * OGforge
 * A single-file canvas game.
 */

// --- Constants & Config ---
const TILE_SIZE = 48;

// Tile IDs
const T_FLOOR = 0;
const T_WALL = 1;
const T_COAL = 2;
const T_IRON = 3;
const T_GOLD = 4;
const T_DIAMOND = 5;
const T_EMERALD = 6;
const T_RUBY = 7;
const T_SAPPHIRE = 8;
const T_AMETHYST = 11;
const T_TOPAZ = 13;
const T_OPAL = 14;
const T_TITANIUM = 15;
const T_PLATINUM = 16;
const T_OBSIDIAN = 17;
const T_JADE = 18;
const T_ONYX = 19;
const T_MYTHRIL = 20;
const T_CELESTITE = 21;
const T_VOIDSTONE = 22;
const T_BEDROCK = 9;
const T_FORGE = 10;
const T_CACHE = 12;

const ORE_DEFS = {
    coal: { key: 'coal', name: 'Coal', tile: T_COAL, color: '#aab0c4', overlay: 'rgba(210,215,235,0.72)', value: 5, hp: 80, xp: 2, p0: 0.2400, p1: 0.1200, kind: 'lump', bright: false },
    iron: { key: 'iron', name: 'Iron', tile: T_IRON, color: '#d1b19c', overlay: 'rgba(255,184,108,0.82)', value: 15, hp: 120, xp: 4, p0: 0.1050, p1: 0.1350, kind: 'lump', bright: false },
    gold: { key: 'gold', name: 'Gold', tile: T_GOLD, color: '#ffd56a', overlay: 'rgba(255,213,106,0.90)', value: 40, hp: 200, xp: 7, p0: 0.0320, p1: 0.0600, kind: 'lump', bright: false },
    diamond: { key: 'diamond', name: 'Diamond', tile: T_DIAMOND, color: '#39e6ff', overlay: 'rgba(57,230,255,0.95)', value: 100, hp: 300, xp: 12, p0: 0.0095, p1: 0.0200, kind: 'facet', bright: true },
    emerald: { key: 'emerald', name: 'Emerald', tile: T_EMERALD, color: '#46ffb3', overlay: 'rgba(70,255,179,0.95)', value: 180, hp: 420, xp: 18, p0: 0.0022, p1: 0.0076, kind: 'facet', bright: true },
    ruby: { key: 'ruby', name: 'Ruby', tile: T_RUBY, color: '#ff4d6d', overlay: 'rgba(255,77,109,0.95)', value: 260, hp: 550, xp: 24, p0: 0.0010, p1: 0.0046, kind: 'facet', bright: true },
    sapphire: { key: 'sapphire', name: 'Sapphire', tile: T_SAPPHIRE, color: '#55a4ff', overlay: 'rgba(85,164,255,0.95)', value: 380, hp: 700, xp: 32, p0: 0.00055, p1: 0.0031, kind: 'facet', bright: true },
    amethyst: { key: 'amethyst', name: 'Amethyst', tile: T_AMETHYST, color: '#bda6ff', overlay: 'rgba(189,166,255,0.95)', value: 600, hp: 900, xp: 42, p0: 0.00025, p1: 0.0022, kind: 'facet', bright: true },
    topaz: { key: 'topaz', name: 'Topaz', tile: T_TOPAZ, color: '#ffd27a', overlay: 'rgba(255,210,122,0.92)', value: 850, hp: 1100, xp: 54, p0: 0.00018, p1: 0.0018, kind: 'facet', bright: true },
    opal: { key: 'opal', name: 'Opal', tile: T_OPAL, color: '#a7f0ff', overlay: 'rgba(167,240,255,0.95)', value: 1100, hp: 1300, xp: 66, p0: 0.00014, p1: 0.0014, kind: 'facet', bright: true },
    titanium: { key: 'titanium', name: 'Titanium', tile: T_TITANIUM, color: '#b6c1d6', overlay: 'rgba(182,193,214,0.86)', value: 1450, hp: 1550, xp: 82, p0: 0.0001, p1: 0.0010, kind: 'lump', bright: false },
    platinum: { key: 'platinum', name: 'Platinum', tile: T_PLATINUM, color: '#e2e4ff', overlay: 'rgba(226,228,255,0.9)', value: 1900, hp: 1750, xp: 98, p0: 0.00008, p1: 0.00085, kind: 'lump', bright: false },
    obsidian: { key: 'obsidian', name: 'Obsidian', tile: T_OBSIDIAN, color: '#3a2b3d', overlay: 'rgba(118,88,140,0.75)', value: 2400, hp: 2050, xp: 120, p0: 0.00006, p1: 0.00065, kind: 'lump', bright: false },
    jade: { key: 'jade', name: 'Jade', tile: T_JADE, color: '#48f0a0', overlay: 'rgba(72,240,160,0.9)', value: 3000, hp: 2350, xp: 150, p0: 0.000045, p1: 0.0005, kind: 'facet', bright: true },
    onyx: { key: 'onyx', name: 'Onyx', tile: T_ONYX, color: '#525a70', overlay: 'rgba(120,130,168,0.85)', value: 3800, hp: 2700, xp: 190, p0: 0.00003, p1: 0.00035, kind: 'facet', bright: true },
    mythril: { key: 'mythril', name: 'Mythril', tile: T_MYTHRIL, color: '#6bdcff', overlay: 'rgba(107,220,255,0.95)', value: 4800, hp: 3200, xp: 240, p0: 0.00002, p1: 0.00022, kind: 'facet', bright: true },
    celestite: { key: 'celestite', name: 'Celestite', tile: T_CELESTITE, color: '#a7b8ff', overlay: 'rgba(170,184,255,0.95)', value: 6200, hp: 3800, xp: 310, p0: 0.000012, p1: 0.00012, kind: 'facet', bright: true },
    voidstone: { key: 'voidstone', name: 'Voidstone', tile: T_VOIDSTONE, color: '#b07dff', overlay: 'rgba(176,125,255,0.95)', value: 8200, hp: 4600, xp: 420, p0: 0.000006, p1: 0.00008, kind: 'facet', bright: true }
};

const ORE_UI_ORDER = [
    'coal', 'iron', 'gold', 'diamond', 'emerald', 'ruby', 'sapphire', 'amethyst',
    'topaz', 'opal', 'titanium', 'platinum', 'obsidian', 'jade', 'onyx', 'mythril', 'celestite', 'voidstone'
];

const ORE_DIST_ORDER = [
    'voidstone', 'celestite', 'mythril', 'onyx', 'jade', 'obsidian', 'platinum', 'titanium',
    'opal', 'topaz', 'amethyst', 'sapphire', 'ruby', 'emerald', 'diamond', 'gold', 'iron', 'coal'
];

const ORES = ORE_UI_ORDER.map((key) => ORE_DEFS[key]).filter(Boolean);
const ORE_DIST = ORE_DIST_ORDER.map((key) => ORE_DEFS[key]).filter(Boolean);
const ORE_BY_KEY = {};
const ORE_BY_TILE = {};
for (const ore of ORES) {
    ORE_BY_KEY[ore.key] = ore;
    ORE_BY_TILE[ore.tile] = ore;
}

// Colors
const COLORS = {
    [T_FLOOR]: '#151520',
    [T_WALL]: '#232336',
    [T_BEDROCK]: '#0a0a10',
    [T_FORGE]: '#ff4d6d',
    [T_CACHE]: '#ffd56a'
};
for (const ore of ORES) {
    COLORS[ore.tile] = ore.color;
}

const DEFAULT_LEVELS = {
    pick: 1,
    boots: 1,
    light: 1,
    reach: 1,
    smelt: 1,
    luck: 1,
    drill: 1,
    xp: 1,
    crit: 1,
    rigcore: 1,
    magnet: 1
};

function makeEmptyInventory() {
    const inv = {};
    for (const ore of ORES) inv[ore.key] = 0;
    return inv;
}

function normalizeInventory(inv) {
    const out = makeEmptyInventory();
    if (!inv || typeof inv !== 'object') return out;
    for (const ore of ORES) {
        const raw = Number(inv[ore.key] ?? 0);
        if (Number.isFinite(raw) && raw > 0) out[ore.key] = Math.floor(raw);
    }
    return out;
}

function normalizeLevels(levels) {
    const out = { ...DEFAULT_LEVELS };
    if (!levels || typeof levels !== 'object') return out;
    for (const key of Object.keys(DEFAULT_LEVELS)) {
        const raw = Number(levels[key]);
        if (Number.isFinite(raw) && raw >= 1) out[key] = Math.floor(raw);
    }
    return out;
}

function xpForLevel(level) {
    const l = Math.max(1, Math.floor(level || 1));
    return Math.floor(80 + Math.pow(l, 1.55) * 45);
}

// Art palette (used for gradients/glows)
const ART = {
    bg0: '#07070a',
    bg1: '#0c0c12',
    floor0: '#12121b',
    floor1: '#1a1a27',
    wall0: '#1b1b2a',
    wall1: '#2a2a40',
    bedrock0: '#06060b',
    bedrock1: '#0f0f18',
    forgeHot: '#ff4d6d',
    forgeWarm: '#ffb020',
    uiText: '#eef0ff'
};

const SAVE_KEY_LEGACY = 'ogforge-save-v1';
const SAVE_INDEX_KEY = 'ogforge-saves-index-v1';
const SAVE_SLOT_PREFIX = 'ogforge-save-slot-v1:';

const OGFORGE_STORAGE = (() => {
    try {
        const s = window.ogforgeStore;
        if (s && typeof s.getItem === 'function' && typeof s.setItem === 'function' && typeof s.removeItem === 'function') {
            return s;
        }
    } catch {}
    return localStorage;
})();

const TRADER_CODE_USED_KEY = 'ogforge-trader-code-hiilikefeet-used-v1';
const REDEEMABLE_CODES_KEY = 'ogforge-redeemable-codes-v1';

function safeGet(key) {
    try { return OGFORGE_STORAGE.getItem(key); } catch { return null; }
}
function safeSet(key, value) {
    try { OGFORGE_STORAGE.setItem(key, String(value)); } catch {}
}

function showToast(msg, ms = 4200) {
    const toast = document.getElementById('boot-toast');
    if (!toast) return;
    toast.textContent = String(msg || '');
    toast.style.opacity = '1';
    window.setTimeout(() => (toast.style.opacity = '0'), ms);
}

function loadRedeemableCodes() {
    try {
        const raw = safeGet(REDEEMABLE_CODES_KEY);
        if (!raw) return [];
        const arr = JSON.parse(raw);
        if (!Array.isArray(arr)) return [];
        return arr.filter((x) => x && typeof x.code === 'string');
    } catch {
        return [];
    }
}

function saveRedeemableCodes(list) {
    try {
        safeSet(REDEEMABLE_CODES_KEY, JSON.stringify(Array.isArray(list) ? list : []));
    } catch {}
}

function generateRedeemCode() {
    const alphabet = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    const pick = () => alphabet[Math.floor(Math.random() * alphabet.length)];
    const part = (n) => Array.from({ length: n }, pick).join('');
    return `${part(4)}-${part(4)}`;
}

const ORE_UI_STATE_KEY = 'ogforge-ore-ui-v1';
const ORE_VISIBLE_KEY = 'ogforge-ore-visible-v1';

const OreUi = {
    init() {
        this.box = document.getElementById('ore-box');
        this.list = document.getElementById('ore-list');
        this.filter = document.getElementById('ore-filter');
        this.filterGrid = document.getElementById('ore-filter-grid');
        this.filterBtn = document.getElementById('ore-filter-btn');
        this.toggleBtn = document.getElementById('ore-toggle');
        this.inventoryList = document.getElementById('forge-inventory-list');
        if (!this.box || !this.list || !this.filterGrid || !this.inventoryList) return;

        this.visible = this._loadVisibility();
        this._buildOreList();
        this._buildInventoryList();
        this._buildFilter();

        const collapsed = this._loadCollapsed();
        this.setCollapsed(collapsed);

        if (this.toggleBtn) {
            this.toggleBtn.addEventListener('click', () => this.setCollapsed(!this.isCollapsed));
        }
        if (this.filterBtn) {
            this.filterBtn.addEventListener('click', () => {
                if (this.isCollapsed || !this.filter) return;
                this.filter.hidden = !this.filter.hidden;
            });
        }
    },
    _buildOreList() {
        this.list.innerHTML = '';
        for (const ore of ORES) {
            const row = document.createElement('div');
            row.className = 'ore-row';
            row.dataset.oreKey = ore.key;
            const left = document.createElement('div');
            left.className = 'ore-left';
            const dot = document.createElement('span');
            dot.className = 'stat-icon';
            dot.style.background = ore.color;
            if (ore.key === 'coal') dot.style.border = '1px solid rgba(255,255,255,.35)';
            const name = document.createElement('span');
            name.textContent = ore.name;
            left.appendChild(dot);
            left.appendChild(name);
            const count = document.createElement('span');
            count.className = 'ore-count';
            count.id = `ui-${ore.key}`;
            count.textContent = '0';
            row.appendChild(left);
            row.appendChild(count);
            this.list.appendChild(row);
        }
        this.applyVisibility();
    },
    _buildInventoryList() {
        this.inventoryList.innerHTML = '';
        for (const ore of ORES) {
            const item = document.createElement('div');
            item.style.display = 'flex';
            item.style.justifyContent = 'space-between';
            item.style.alignItems = 'center';
            item.style.padding = '8px 10px';
            item.style.borderRadius = '12px';
            item.style.background = 'rgba(0,0,0,.18)';
            item.style.border = '1px solid rgba(255,255,255,.06)';

            const left = document.createElement('span');
            const dot = document.createElement('span');
            dot.style.display = 'inline-block';
            dot.style.width = '10px';
            dot.style.height = '10px';
            dot.style.borderRadius = '50%';
            dot.style.background = ore.color;
            dot.style.marginRight = '8px';
            dot.style.boxShadow = '0 0 0 1px rgba(255,255,255,.10)';
            if (ore.key === 'coal') dot.style.border = '1px solid rgba(255,255,255,.35)';
            left.appendChild(dot);
            left.appendChild(document.createTextNode(ore.name));

            const right = document.createElement('span');
            const count = document.createElement('span');
            count.id = `ui-${ore.key}-menu`;
            count.textContent = '0';
            right.appendChild(count);
            right.appendChild(document.createTextNode(` · $${ORE_VALUE[ore.key]}`));

            item.appendChild(left);
            item.appendChild(right);
            this.inventoryList.appendChild(item);
        }
    },
    _buildFilter() {
        this.filterGrid.innerHTML = '';
        for (const ore of ORES) {
            const label = document.createElement('label');
            label.className = 'ore-filter-item';
            label.dataset.oreKey = ore.key;
            const input = document.createElement('input');
            input.type = 'checkbox';
            input.checked = this.visible[ore.key] !== false;
            input.addEventListener('change', () => {
                this.visible[ore.key] = input.checked;
                this.applyVisibility();
                this._saveVisibility();
            });
            const text = document.createElement('span');
            text.textContent = ore.name;
            label.appendChild(input);
            label.appendChild(text);
            this.filterGrid.appendChild(label);
        }

        const btnAll = document.getElementById('ore-filter-all');
        const btnNone = document.getElementById('ore-filter-none');
        if (btnAll) {
            btnAll.addEventListener('click', () => {
                for (const ore of ORES) this.visible[ore.key] = true;
                this._syncFilterChecks();
                this.applyVisibility();
                this._saveVisibility();
            });
        }
        if (btnNone) {
            btnNone.addEventListener('click', () => {
                for (const ore of ORES) this.visible[ore.key] = false;
                this._syncFilterChecks();
                this.applyVisibility();
                this._saveVisibility();
            });
        }
    },
    _syncFilterChecks() {
        const inputs = this.filterGrid.querySelectorAll('input[type="checkbox"]');
        for (const input of inputs) {
            const label = input.closest('label');
            const key = label ? label.dataset.oreKey : '';
            if (key) input.checked = this.visible[key] !== false;
        }
    },
    applyVisibility() {
        const rows = this.list.querySelectorAll('.ore-row');
        for (const row of rows) {
            const key = row.dataset.oreKey;
            row.style.display = this.visible[key] === false ? 'none' : '';
        }
    },
    setCollapsed(collapsed) {
        this.isCollapsed = Boolean(collapsed);
        this.box.dataset.collapsed = this.isCollapsed ? 'true' : 'false';
        if (this.toggleBtn) this.toggleBtn.textContent = this.isCollapsed ? '+' : '–';
        if (this.filter) this.filter.hidden = true;
        this._saveCollapsed();
    },
    _loadCollapsed() {
        try {
            const raw = safeGet(ORE_UI_STATE_KEY);
            const parsed = raw ? JSON.parse(raw) : null;
            return Boolean(parsed && parsed.collapsed);
        } catch {
            return false;
        }
    },
    _saveCollapsed() {
        try {
            safeSet(ORE_UI_STATE_KEY, JSON.stringify({ collapsed: this.isCollapsed }));
        } catch {}
    },
    _loadVisibility() {
        try {
            const raw = safeGet(ORE_VISIBLE_KEY);
            const parsed = raw ? JSON.parse(raw) : null;
            const vis = {};
            for (const ore of ORES) vis[ore.key] = parsed ? parsed[ore.key] !== false : true;
            return vis;
        } catch {
            const vis = {};
            for (const ore of ORES) vis[ore.key] = true;
            return vis;
        }
    },
    _saveVisibility() {
        try {
            safeSet(ORE_VISIBLE_KEY, JSON.stringify(this.visible));
        } catch {}
    }
};

function clamp01(v) {
    return Math.max(0, Math.min(1, v));
}

function hash2(x, y) {
    let h = (x * 374761393 + y * 668265263) >>> 0;
    h = Math.imul(h ^ (h >>> 13), 1274126177) >>> 0;
    return (h ^ (h >>> 16)) >>> 0;
}

function seeded01(seed) {
    const n = (Math.imul(seed >>> 0, 1664525) + 1013904223) >>> 0;
    return n / 4294967296;
}

function roundRectPath(ctx, x, y, w, h, r) {
    const radius = Math.max(0, Math.min(r, w / 2, h / 2));
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.arcTo(x + w, y, x + w, y + h, radius);
    ctx.arcTo(x + w, y + h, x, y + h, radius);
    ctx.arcTo(x, y + h, x, y, radius);
    ctx.arcTo(x, y, x + w, y, radius);
    ctx.closePath();
}

function isBrightOre(tileType) {
    const ore = ORE_BY_TILE[tileType];
    return Boolean(ore && ore.bright);
}

const SaveManager = {
    _safeReadJson(key) {
        try {
            const raw = OGFORGE_STORAGE.getItem(key);
            if (!raw) return null;
            return JSON.parse(raw);
        } catch {
            return null;
        }
    },
    _safeWriteJson(key, value) {
        try {
            OGFORGE_STORAGE.setItem(key, JSON.stringify(value));
            return true;
        } catch {
            return false;
        }
    },
    _safeRemove(key) {
        try {
            OGFORGE_STORAGE.removeItem(key);
        } catch {}
    },
    _uuid() {
        try {
            if (crypto && crypto.randomUUID) return crypto.randomUUID();
        } catch {}
        return `m_${Math.random().toString(16).slice(2)}_${Date.now().toString(16)}`;
    },
    _hashString32(str) {
        // FNV-1a 32-bit
        let h = 0x811c9dc5;
        const s = String(str || '');
        for (let i = 0; i < s.length; i++) {
            h ^= s.charCodeAt(i) & 0xff;
            h = Math.imul(h, 0x01000193) >>> 0;
        }
        return h >>> 0;
    },
    _randU32() {
        try {
            const a = new Uint32Array(1);
            crypto.getRandomValues(a);
            return a[0] >>> 0;
        } catch {
            return ((Math.random() * 0xffffffff) >>> 0);
        }
    },
    _ensureSlotSeed(slot) {
        if (!slot || typeof slot !== 'object') return;
        if (Number.isFinite(slot.seed)) {
            slot.seed = (slot.seed >>> 0);
            return;
        }
        slot.seed = this._hashString32(slot.id || this._uuid()) >>> 0;
    },
    _readIndex() {
        const idx = this._safeReadJson(SAVE_INDEX_KEY);
        if (!idx || idx.v !== 1 || !Array.isArray(idx.slots)) return null;
        for (const s of idx.slots) this._ensureSlotSeed(s);
        return idx;
    },
    _writeIndex(index) {
        if (index && Array.isArray(index.slots)) {
            for (const s of index.slots) this._ensureSlotSeed(s);
        }
        return this._safeWriteJson(SAVE_INDEX_KEY, index);
    },
    _ensureIndex() {
        let idx = this._readIndex();
        if (idx) return idx;
        idx = { v: 1, currentId: null, slots: [] };
        this._writeIndex(idx);
        return idx;
    },
    _slotKey(id) {
        return `${SAVE_SLOT_PREFIX}${id}`;
    },
    _touchSlotMeta(id, patch) {
        const idx = this._ensureIndex();
        const slot = idx.slots.find(s => s.id === id);
        if (!slot) return false;
        Object.assign(slot, patch);
        this._writeIndex(idx);
        return true;
    },
    listSlots() {
        const idx = this._ensureIndex();
        return idx.slots.slice().sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0));
    },
    getCurrentSlotId() {
        const idx = this._ensureIndex();
        return idx.currentId || null;
    },
    getCurrentSlot() {
        const idx = this._ensureIndex();
        return idx.slots.find(s => s.id === idx.currentId) || null;
    },
    setCurrentSlotId(id) {
        const idx = this._ensureIndex();
        if (!idx.slots.some(s => s.id === id)) return false;
        idx.currentId = id;
        this._writeIndex(idx);
        return true;
    },
    createSlot(name) {
        const idx = this._ensureIndex();
        const trimmed = (name || '').trim().slice(0, 24);
        const nextNum = idx.slots.length + 1;
        const slotName = trimmed || `Mine ${nextNum}`;
        const id = this._uuid();
        const now = Date.now();
        const slot = { id, name: slotName, createdAt: now, updatedAt: now };
        this._ensureSlotSeed(slot);
        idx.slots.push(slot);
        idx.currentId = id;
        this._writeIndex(idx);
        return id;
    },
    migrateLegacyIfPresent() {
        const legacy = this._safeReadJson(SAVE_KEY_LEGACY);
        if (!legacy || legacy.v !== 1) return;

        const idx = this._ensureIndex();
        const already = idx.slots.some(s => s.legacy === true);
        if (already) {
            this._safeRemove(SAVE_KEY_LEGACY);
            return;
        }

        const id = this._uuid();
        const now = Date.now();
        this._safeWriteJson(this._slotKey(id), legacy);
        const slot = { id, name: 'Mine 1', createdAt: now, updatedAt: legacy.ts || now, legacy: true };
        this._ensureSlotSeed(slot);
        idx.slots.push(slot);
        idx.currentId = id;
        this._writeIndex(idx);
        this._safeRemove(SAVE_KEY_LEGACY);
    },
    ensureCurrentSlot() {
        this.migrateLegacyIfPresent();
        const idx = this._ensureIndex();
        if (idx.currentId && idx.slots.some(s => s.id === idx.currentId)) return idx.currentId;
        if (idx.slots.length > 0) {
            idx.currentId = idx.slots[0].id;
            this._writeIndex(idx);
            return idx.currentId;
        }
        return this.createSlot('Mine 1');
    },
    hasSave() {
        const id = this.ensureCurrentSlot();
        const parsed = this._safeReadJson(this._slotKey(id));
        return !!parsed && parsed.v === 1;
    },
    load() {
        const id = this.ensureCurrentSlot();
        const parsed = this._safeReadJson(this._slotKey(id));
        if (!parsed || parsed.v !== 1) return null;
        return parsed;
    },
    save(state) {
        const id = this.ensureCurrentSlot();
        const ok = this._safeWriteJson(this._slotKey(id), state);
        if (ok) this._touchSlotMeta(id, { updatedAt: state.ts || Date.now() });
        return ok;
    },
    saveToSlot(id, state) {
        if (!id) return false;
        const idx = this._ensureIndex();
        if (!idx.slots.some(s => s.id === id)) return false;
        const ok = this._safeWriteJson(this._slotKey(id), state);
        if (ok) this._touchSlotMeta(id, { updatedAt: state.ts || Date.now() });
        return ok;
    },
    clear() {
        const id = this.ensureCurrentSlot();
        this._safeRemove(this._slotKey(id));
        this._touchSlotMeta(id, { updatedAt: Date.now() });
    }
};

class TileArt {
    constructor(tileSize) {
        this.tileSize = tileSize;
        this.variants = 12;
        this.cache = new Map();
        this._buildAll();
    }

    get(type, x, y) {
        const v = hash2(x, y) % this.variants;
        return this.cache.get(`${type}:${v}`) || this.cache.get(`${type}:0`);
    }

    _canvas() {
        const c = document.createElement('canvas');
        c.width = this.tileSize;
        c.height = this.tileSize;
        return c;
    }

    _speckle(ctx, seed, color, count, sizeMin, sizeMax, alphaMin, alphaMax) {
        for (let i = 0; i < count; i++) {
            const s = (seed + i * 9973) >>> 0;
            const rx = seeded01(s) * this.tileSize;
            const ry = seeded01(s ^ 0x9e3779b9) * this.tileSize;
            const r = sizeMin + seeded01(s ^ 0x85ebca6b) * (sizeMax - sizeMin);
            const a = alphaMin + seeded01(s ^ 0xc2b2ae35) * (alphaMax - alphaMin);
            ctx.globalAlpha = a;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(rx, ry, r, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }

    _stoneBase(ctx, seed, c0, c1) {
        const g = ctx.createLinearGradient(0, 0, this.tileSize, this.tileSize);
        g.addColorStop(0, c0);
        g.addColorStop(1, c1);
        ctx.fillStyle = g;
        roundRectPath(ctx, 0.5, 0.5, this.tileSize - 1, this.tileSize - 1, 10);
        ctx.fill();

        // Soft inner shadow / depth
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.lineWidth = 1;
        roundRectPath(ctx, 1.5, 1.5, this.tileSize - 3, this.tileSize - 3, 9);
        ctx.stroke();

        // Texture
        this._speckle(ctx, seed ^ 0x1234, 'rgba(255,255,255,0.08)', 28, 0.6, 1.6, 0.10, 0.35);
        this._speckle(ctx, seed ^ 0x5678, 'rgba(0,0,0,0.25)', 22, 0.8, 2.2, 0.08, 0.22);

        // Edge vignette
        const vg = ctx.createRadialGradient(
            this.tileSize / 2,
            this.tileSize / 2,
            this.tileSize * 0.12,
            this.tileSize / 2,
            this.tileSize / 2,
            this.tileSize * 0.75
        );
        vg.addColorStop(0, 'rgba(0,0,0,0)');
        vg.addColorStop(1, 'rgba(0,0,0,0.22)');
        ctx.fillStyle = vg;
        roundRectPath(ctx, 0.5, 0.5, this.tileSize - 1, this.tileSize - 1, 10);
        ctx.fill();
    }

    _oreOverlay(ctx, seed, color, kind) {
        const cx = this.tileSize / 2;
        const cy = this.tileSize / 2;

        // Subtle glow
        ctx.globalAlpha = 0.9;
        ctx.shadowColor = color;
        ctx.shadowBlur = 18;
        ctx.fillStyle = color;

        if (kind === 'facet') {
            ctx.beginPath();
            ctx.moveTo(cx, cy - 10);
            ctx.lineTo(cx + 10, cy);
            ctx.lineTo(cx, cy + 10);
            ctx.lineTo(cx - 10, cy);
            ctx.closePath();
            ctx.fill();
        } else {
            const n = 3 + Math.floor(seeded01(seed ^ 0xaaa) * 2);
            for (let i = 0; i < n; i++) {
                const s = (seed + i * 7919) >>> 0;
                const ox = (seeded01(s) - 0.5) * 16;
                const oy = (seeded01(s ^ 0x9e37) - 0.5) * 16;
                const r = 4 + seeded01(s ^ 0x85eb) * 5;
                ctx.beginPath();
                ctx.arc(cx + ox, cy + oy, r, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;

        // Specular highlight
        ctx.globalAlpha = 0.25;
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(cx - 6, cy - 7, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }

    _build(type, v, drawFn) {
        const c = this._canvas();
        const ctx = c.getContext('2d');
        drawFn(ctx, (type * 1000 + v * 1337) >>> 0);
        this.cache.set(`${type}:${v}`, c);
    }

    _buildAll() {
        for (let v = 0; v < this.variants; v++) {
            this._build(T_FLOOR, v, (ctx, seed) => {
                this._stoneBase(ctx, seed, ART.floor0, ART.floor1);
            });

            this._build(T_WALL, v, (ctx, seed) => {
                this._stoneBase(ctx, seed, ART.wall0, ART.wall1);
                // Bevel highlights
                const gTop = ctx.createLinearGradient(0, 0, 0, 10);
                gTop.addColorStop(0, 'rgba(255,255,255,0.10)');
                gTop.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = gTop;
                roundRectPath(ctx, 1, 1, this.tileSize - 2, 12, 9);
                ctx.fill();
            });

            this._build(T_BEDROCK, v, (ctx, seed) => {
                this._stoneBase(ctx, seed, ART.bedrock0, ART.bedrock1);
                this._speckle(ctx, seed ^ 0xdead, 'rgba(255,255,255,0.05)', 18, 0.8, 2.6, 0.06, 0.18);
                // Darken edges more
                ctx.globalAlpha = 0.35;
                ctx.fillStyle = '#000';
                roundRectPath(ctx, 0.5, 0.5, this.tileSize - 1, this.tileSize - 1, 10);
                ctx.fill();
                ctx.globalAlpha = 1;
            });

            const oreBuild = (type, color, kind) => {
                this._build(type, v, (ctx, seed) => {
                    this._stoneBase(ctx, seed, ART.wall0, ART.wall1);
                    this._oreOverlay(ctx, seed ^ 0x1337, color, kind);
                });
            };

            for (const ore of ORES) {
                oreBuild(ore.tile, ore.overlay, ore.kind);
            }

            this._build(T_CACHE, v, (ctx, seed) => {
                this._stoneBase(ctx, seed, ART.floor0, ART.floor1);

                // Chest base
                ctx.save();
                ctx.shadowColor = 'rgba(255,213,106,0.65)';
                ctx.shadowBlur = 14;
                const x = 10;
                const y = 18;
                const w = this.tileSize - 20;
                const h = this.tileSize - 26;
                const g = ctx.createLinearGradient(0, y, 0, y + h);
                g.addColorStop(0, 'rgba(255,213,106,0.95)');
                g.addColorStop(1, 'rgba(255,176,32,0.82)');
                ctx.fillStyle = g;
                roundRectPath(ctx, x, y, w, h, 10);
                ctx.fill();

                // Lid line
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 0.35;
                ctx.fillStyle = '#000';
                roundRectPath(ctx, x + 1, y + 10, w - 2, 2, 2);
                ctx.fill();
                ctx.globalAlpha = 1;

                // Lock
                ctx.fillStyle = 'rgba(20,20,28,0.95)';
                roundRectPath(ctx, this.tileSize / 2 - 4, y + 12, 8, 10, 3);
                ctx.fill();
                ctx.fillStyle = 'rgba(255,255,255,0.75)';
                ctx.beginPath();
                ctx.arc(this.tileSize / 2, y + 16, 1.4, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }
    }
}

// Mining Health (Hits required)
const TILE_HP = {
    [T_WALL]: 60
};
for (const ore of ORES) {
    TILE_HP[ore.tile] = ore.hp;
}

// Ore Values
const ORE_VALUE = {};
for (const ore of ORES) {
    ORE_VALUE[ore.key] = ore.value;
}

// --- Game Engine Classes ---

class Input {
    constructor() {
        this.keys = {};
        this.mouse = { x: 0, y: 0, down: false };
        this.worldMouse = { x: 0, y: 0 };

        window.addEventListener('keydown', e => this.keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
        
        window.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            this.mouse.x = e.clientX - rect.left;
            this.mouse.y = e.clientY - rect.top;
        });

        window.addEventListener('mousedown', () => this.mouse.down = true);
        window.addEventListener('mouseup', () => this.mouse.down = false);
        
        // Touch controls for mining
        window.addEventListener('touchstart', (e) => {
             const rect = canvas.getBoundingClientRect();
             this.mouse.x = e.touches[0].clientX - rect.left;
             this.mouse.y = e.touches[0].clientY - rect.top;
             this.mouse.down = true;
             e.preventDefault();
        }, {passive: false});

        window.addEventListener('touchmove', (e) => {
            const rect = canvas.getBoundingClientRect();
            this.mouse.x = e.touches[0].clientX - rect.left;
            this.mouse.y = e.touches[0].clientY - rect.top;
            e.preventDefault();
        }, {passive: false});
        
        window.addEventListener('touchend', () => this.mouse.down = false);
    }
}

class Camera {
    constructor(width, height) {
        this.x = 0;
        this.y = 0;
        this.width = width;
        this.height = height;
    }
    
    follow(target, mapWidthPx, mapHeightPx) {
        // Center on target
        this.x = target.x - this.width / 2;
        this.y = target.y - this.height / 2;
        
        // Clamp to bounds (only when provided)
        if (Number.isFinite(mapWidthPx) && Number.isFinite(mapHeightPx)) {
            this.x = Math.max(0, Math.min(this.x, mapWidthPx - this.width));
            this.y = Math.max(0, Math.min(this.y, mapHeightPx - this.height));
        }
    }
}

class Particle {
    constructor(x, y, color, speed, life) {
        this.x = x;
        this.y = y;
        this.color = color;
        const angle = Math.random() * Math.PI * 2;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = life;
        this.maxLife = life;
        this.size = Math.random() * 3 + 1;
        this.gravity = 0.1;
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += this.gravity; // Gravity
        this.vx *= 0.95; // Friction
        this.life--;
    }
    
    draw(ctx, camX, camY) {
        const a = this.life / this.maxLife;
        ctx.globalAlpha = a;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x - camX, this.y - camY, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

class Shockwave {
    constructor(x, y, color, maxRadius, life) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.maxRadius = maxRadius;
        this.life = life;
        this.maxLife = life;
    }

    update() {
        this.life--;
    }

    draw(ctx, camX, camY) {
        const t = 1 - this.life / this.maxLife;
        const r = 4 + this.maxRadius * t;
        const a = Math.max(0, 1 - t);
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = 0.55 * a;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x - camX, this.y - camY, r, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 0.25 * a;
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.arc(this.x - camX, this.y - camY, r * 0.7, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
    }
}

class DrillRig {
    constructor(tx, ty) {
        this.tx = tx;
        this.ty = ty;
        this.x = tx * TILE_SIZE + TILE_SIZE / 2;
        this.y = ty * TILE_SIZE + TILE_SIZE / 2;
        this.cooldown = 0;
        this.target = null;
        this.life = 1;
    }

    _findTarget(map) {
        const r = 3;
        let best = null;
        for (let dy = -r; dy <= r; dy++) {
            for (let dx = -r; dx <= r; dx++) {
                const tx = this.tx + dx;
                const ty = this.ty + dy;
                const t = map.getTile(tx, ty);
                if (t === T_FLOOR || t === T_BEDROCK || t === T_FORGE || t === T_CACHE) continue;
                const hp = map.getHp(tx, ty);
                if (hp <= 0) continue;
                const d2 = dx * dx + dy * dy;
                if (!best || d2 < best.d2) best = { tx, ty, d2, t };
            }
        }
        this.target = best;
    }

    update(game) {
        if (this.cooldown > 0) this.cooldown--;
        if (!this.target || game.map.getTile(this.target.tx, this.target.ty) === T_FLOOR) this._findTarget(game.map);
        if (!this.target) return;
        if (this.cooldown > 0) return;

        const { tx, ty } = this.target;
        const tile = game.map.getTile(tx, ty);
        if (tile === T_FLOOR || tile === T_BEDROCK || tile === T_FORGE || tile === T_CACHE) {
            this.target = null;
            return;
        }

        const power = game.player.drillPower;
        const interval = game.player.drillInterval;
        this.cooldown = interval;

        const hp = game.map.getHp(tx, ty) - power;
        game.map.setHp(tx, ty, hp);

        const wx = tx * TILE_SIZE + TILE_SIZE / 2;
        const wy = ty * TILE_SIZE + TILE_SIZE / 2;
        const c = COLORS[tile] || '#fff';
        game.particles.push(new Particle(wx, wy, c, 2.2, 18));
        if (Math.random() < 0.35) game.effects.push(new Shockwave(wx, wy, c, 14, 10));

        if (hp <= 0) game.breakTile(tx, ty, tile);
    }

    draw(ctx, camX, camY, time) {
        const x = this.x - camX;
        const y = this.y - camY;
        const t = time || 0;
        const pulse = 0.5 + 0.5 * Math.sin(t * 0.14 + (this.tx + this.ty) * 0.3);

        ctx.save();
        ctx.translate(x, y);
        ctx.shadowColor = 'rgba(255,176,32,0.45)';
        ctx.shadowBlur = 12;
        ctx.fillStyle = 'rgba(20,20,28,0.92)';
        roundRectPath(ctx, -14, -10, 28, 22, 10);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.strokeStyle = 'rgba(255,255,255,0.12)';
        ctx.lineWidth = 1;
        roundRectPath(ctx, -14, -10, 28, 22, 10);
        ctx.stroke();

        // Bit
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = 0.65 + 0.25 * pulse;
        ctx.fillStyle = 'rgba(255,176,32,0.95)';
        ctx.beginPath();
        ctx.moveTo(10, -4);
        ctx.lineTo(18, 0);
        ctx.lineTo(10, 4);
        ctx.closePath();
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = 'source-over';

        // Base feet
        ctx.fillStyle = 'rgba(0,0,0,0.35)';
        roundRectPath(ctx, -16, 10, 32, 6, 4);
        ctx.fill();
        ctx.restore();
    }
}

class AudioManager {
    constructor() {
        this.ctx = null;
        this.master = null;
        this._humOsc = null;
        this._humGain = null;
    }

    ensure() {
        if (!this.ctx) {
            const Ctx = window.AudioContext || window.webkitAudioContext;
            if (!Ctx) return;
            this.ctx = new Ctx();
            this.master = this.ctx.createGain();
            this.master.gain.value = 0.45;
            this.master.connect(this.ctx.destination);
        }
        if (this.ctx.state === 'suspended') this.ctx.resume();
    }

    _noise(durationSec, filterHz, gainValue) {
        this.ensure();
        if (!this.ctx) return;
        const sr = this.ctx.sampleRate;
        const frames = Math.max(1, Math.floor(sr * durationSec));
        const buffer = this.ctx.createBuffer(1, frames, sr);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < frames; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / frames);

        const src = this.ctx.createBufferSource();
        src.buffer = buffer;

        const filter = this.ctx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = filterHz;

        const gain = this.ctx.createGain();
        gain.gain.value = gainValue;

        src.connect(filter);
        filter.connect(gain);
        gain.connect(this.master);

        const now = this.ctx.currentTime;
        gain.gain.setValueAtTime(gainValue, now);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + durationSec);
        src.start();
        src.stop(now + durationSec);
    }

    _tone(freq, durationSec, gainValue, type = 'sine') {
        this.ensure();
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        gain.gain.value = gainValue;
        osc.connect(gain);
        gain.connect(this.master);
        const now = this.ctx.currentTime;
        gain.gain.setValueAtTime(gainValue, now);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + durationSec);
        osc.start();
        osc.stop(now + durationSec);
    }

    playMineHit(tileType) {
        const bright = isBrightOre(tileType) ? 1600 : 1100;
        this._noise(0.045, bright, 0.18);
        this._tone(140 + Math.random() * 40, 0.04, 0.05, 'square');
    }

    playMineBreak(tileType) {
        this._noise(0.085, 900, 0.24);
        if (tileType !== T_WALL && tileType !== T_COAL && tileType !== T_IRON) {
            this._tone(520 + Math.random() * 160, 0.08, 0.06, 'triangle');
        }
    }

    playCacheOpen() {
        this._tone(660, 0.09, 0.10, 'triangle');
        this._tone(990, 0.10, 0.07, 'sine');
        this._noise(0.06, 1400, 0.10);
    }

    startForgeHum() {
        this.ensure();
        if (!this.ctx) return;
        if (this._humOsc) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.value = 58;
        gain.gain.value = 0.00;
        osc.connect(gain);
        gain.connect(this.master);
        osc.start();
        this._humOsc = osc;
        this._humGain = gain;
    }

    setForgeHum(active) {
        if (!this.ctx) return;
        if (!this._humOsc) this.startForgeHum();
        if (!this._humGain) return;
        const now = this.ctx.currentTime;
        const target = active ? 0.06 : 0.0001;
        this._humGain.gain.cancelScheduledValues(now);
        this._humGain.gain.setValueAtTime(this._humGain.gain.value, now);
        this._humGain.gain.exponentialRampToValueAtTime(target, now + 0.12);
    }
}

class Floater {
    constructor(x, y, text, color) {
        this.x = x;
        this.y = y;
        this.text = text;
        this.color = color;
        this.life = 60;
        this.vy = -1;
    }
    
    update() {
        this.y += this.vy;
        this.life--;
    }
    
    draw(ctx, camX, camY) {
        ctx.globalAlpha = Math.max(0, this.life / 60);
        ctx.fillStyle = this.color;
        ctx.font = "700 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
        ctx.strokeStyle = "rgba(0,0,0,0.75)";
        ctx.lineWidth = 4;
        ctx.strokeText(this.text, this.x - camX, this.y - camY);
        ctx.fillText(this.text, this.x - camX, this.y - camY);
        ctx.globalAlpha = 1;
    }
}

class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 10;
        this.speed = 3;
        this.vx = 0;
        this.vy = 0;
        this.facing = 1; // -1 left, +1 right
        this.minePulse = 0; // 0..1
        this.drillRigs = 0;
        
        // Stats
        this.money = 0;
        this.inventory = makeEmptyInventory();
        this.level = 1;
        this.xp = 0;
        
        // Upgrades
        this.miningPower = 2; // Damage per tick
        this.lightRadius = 150;
        this.maxSpeed = 3;
        this.miningRange = 80;
        this.miningInterval = 5; // Damage applied every N ticks while mining
        this.sellMultiplier = 1.0;
        this.luck = 0.0; // Chance for bonus drops
        this.xpBoost = 0.0;
        this.critChance = 0.0;
        this.critMultiplier = 2.0;
        this.drillPower = 2.2;
        this.drillInterval = 12;
        this.oreBonus = 0.0;
        
        // Upgrade Levels (for costs)
        this.levels = { ...DEFAULT_LEVELS };
    }
    
    update(input, map) {
        // Movement Input
        let dx = 0;
        let dy = 0;
        
        if (input.keys['w'] || input.keys['arrowup']) dy = -1;
        if (input.keys['s'] || input.keys['arrowdown']) dy = 1;
        if (input.keys['a'] || input.keys['arrowleft']) dx = -1;
        if (input.keys['d'] || input.keys['arrowright']) dx = 1;
        
        // Normalize vector
        if (dx !== 0 || dy !== 0) {
            const len = Math.sqrt(dx*dx + dy*dy);
            dx /= len;
            dy /= len;
        }
        
        this.vx = dx * this.maxSpeed;
        this.vy = dy * this.maxSpeed;
        if (dx !== 0) this.facing = dx > 0 ? 1 : -1;
        this.minePulse *= 0.86;
        
        // Collision Resolution (X axis)
        let nextX = this.x + this.vx;
        if (!map.isSolidAt(nextX, this.y, this.radius)) {
            this.x = nextX;
        }
        
        // Collision Resolution (Y axis)
        let nextY = this.y + this.vy;
        if (!map.isSolidAt(this.x, nextY, this.radius)) {
            this.y = nextY;
        }
    }

    pulseMine() {
        this.minePulse = Math.min(1, this.minePulse + 0.85);
    }
    
    draw(ctx, camX, camY, time) {
        const px = this.x - camX;
        const py = this.y - camY;
        const t = time || 0;
        const speed = Math.hypot(this.vx, this.vy) / Math.max(0.001, this.maxSpeed);
        const mine = this.minePulse;
        const bob = Math.sin(t * 0.18) * (0.55 + 0.45 * speed);

        // Shadow
        ctx.fillStyle = `rgba(0,0,0,${0.26 + 0.10 * speed})`;
        ctx.beginPath();
        ctx.ellipse(px, py + 12, 9.5 + 2 * speed, 3.2, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.save();
        ctx.translate(px, py + bob);
        ctx.scale(this.facing, 1);

        // Dot body
        const g = ctx.createRadialGradient(-3, -5, 2, 0, 0, 18);
        g.addColorStop(0, '#d9d1ff');
        g.addColorStop(0.55, '#7c5cff');
        g.addColorStop(1, '#4f2bff');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = 'rgba(0,0,0,0.55)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.stroke();

        // Helmet lamp (simple)
        ctx.shadowColor = 'rgba(255,224,138,0.85)';
        ctx.shadowBlur = 16;
        ctx.fillStyle = '#ffe08a';
        ctx.beginPath();
        ctx.arc(6.8, -5.5, 3.7, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        ctx.beginPath();
        ctx.arc(6.1, -6.2, 1.2, 0, Math.PI * 2);
        ctx.fill();

        // Hand + pickaxe (kept simple)
        const handX = 10.0;
        const handY = 6.0;
        ctx.fillStyle = 'rgba(22,22,34,0.9)';
        ctx.beginPath();
        ctx.arc(handX, handY, 2.8, 0, Math.PI * 2);
        ctx.fill();

        ctx.save();
        const swing = (-0.65 + 1.15 * mine) + Math.sin(t * 0.05) * (0.03 + 0.07 * speed);
        ctx.translate(handX, handY);
        ctx.rotate(swing);

        // Handle
        const handleG = ctx.createLinearGradient(0, 0, 0, 24);
        handleG.addColorStop(0, 'rgba(255,213,106,0.80)');
        handleG.addColorStop(1, 'rgba(120,78,18,0.98)');
        ctx.strokeStyle = handleG;
        ctx.lineWidth = 4.2;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(0, -1.5);
        ctx.lineTo(0, 22);
        ctx.stroke();

        // Head
        ctx.shadowColor = 'rgba(57,230,255,0.22)';
        ctx.shadowBlur = 12;
        ctx.fillStyle = 'rgba(210,220,235,0.95)';
        roundRectPath(ctx, -11, -10, 22, 7.8, 4);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 0.65;
        ctx.strokeStyle = 'rgba(0,0,0,0.45)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(-11, -6);
        ctx.lineTo(11, -6);
        ctx.stroke();
        ctx.globalAlpha = 1;

        // Tiny spark on mine
        if (mine > 0.4) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = 0.25 + 0.5 * mine;
            ctx.strokeStyle = 'rgba(255,255,255,0.85)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(12, -8);
            ctx.lineTo(18, -12);
            ctx.stroke();
            ctx.restore();
        }

        ctx.restore();

        ctx.restore();
    }
}

class InfiniteMap {
    constructor(seed) {
        this.setSeed(seed);
        this.modifiedTiles = new Map(); // key -> tileId
        this.modifiedHp = new Map(); // key -> hp
        this.forgeTile = { x: 0, y: -2 };
        this.spawnTile = { x: 0, y: 0 };
    }

    setSeed(seed) {
        const s = Number.isFinite(seed) ? (seed >>> 0) : 0;
        this.seed = s;
        this._seedA = (s ^ 0x9e3779b9) | 0;
        this._seedB = (Math.imul(s ^ 0x85ebca6b, 0xc2b2ae35) ^ 0x27d4eb2f) | 0;
    }

    _h(x, y, salt = 0) {
        const sx = ((x | 0) + this._seedA + (salt | 0)) | 0;
        const sy = ((y | 0) + this._seedB - (salt | 0)) | 0;
        return hash2(sx, sy);
    }

    key(x, y) {
        return `${x},${y}`;
    }

    inSpawnRoom(tx, ty) {
        const dx = tx - this.spawnTile.x;
        const dy = ty - this.spawnTile.y;
        return Math.sqrt(dx * dx + dy * dy) <= 4.2;
    }

    structureTileAt(tx, ty) {
        const spacing = 34;
        const cellX = Math.floor(tx / spacing);
        const cellY = Math.floor(ty / spacing);
        if (Math.abs(cellX) <= 1 && Math.abs(cellY) <= 1) return null;

        const seed = this._h(cellX, cellY, 0x51a7);
        const chance = seeded01(seed ^ 0x5a1f0b);
        if (chance < 0.88) return null;

        const cx = cellX * spacing + Math.floor(spacing / 2) + Math.floor((seeded01(seed ^ 0xa2c3) - 0.5) * (spacing * 0.6));
        const cy = cellY * spacing + Math.floor(spacing / 2) + Math.floor((seeded01(seed ^ 0xf00d) - 0.5) * (spacing * 0.6));

        const w = 9 + Math.floor(seeded01(seed ^ 0x9e37) * 8); // 9..16
        const h = 7 + Math.floor(seeded01(seed ^ 0x7f4a) * 7); // 7..13
        const halfW = Math.floor(w / 2);
        const halfH = Math.floor(h / 2);

        const rx = tx - cx;
        const ry = ty - cy;
        if (Math.abs(rx) > halfW || Math.abs(ry) > halfH) return null;

        const onEdge = Math.abs(rx) === halfW || Math.abs(ry) === halfH;
        if (onEdge) return T_WALL;

        const d = Math.sqrt(tx * tx + ty * ty);
        if (d > 28 && tx === cx && ty === cy && seeded01(seed ^ 0x13371337) > 0.25) return T_CACHE;
        return T_FLOOR;
    }

    baseTileAt(tx, ty) {
        if (tx === this.forgeTile.x && ty === this.forgeTile.y) return T_FORGE;
        if (this.inSpawnRoom(tx, ty)) return T_FLOOR;

        const structure = this.structureTileAt(tx, ty);
        if (structure !== null) return structure;

        // Occasional natural caves
        const caveRand = seeded01(this._h(tx + 18013, ty - 9127, 0x0ca7));
        const d = Math.sqrt(tx * tx + ty * ty);
        const depth = clamp01((d - 8) / 140); // deeper => rarer ores
        const caveChance = 0.05 + 0.03 * depth;
        if (caveRand < caveChance) return T_FLOOR;

        // Ore distribution (deterministic by depth)
        const r = seeded01(this._h(tx, ty, 0x0ae5));
        const lerp = (a, b, t) => a + (b - a) * t;

        let t = r;
        for (const ore of ORE_DIST) {
            const p = lerp(ore.p0, ore.p1, depth);
            if ((t -= p) < 0) return ore.tile;
        }
        return T_WALL;
    }

    getTile(tx, ty) {
        const k = this.key(tx, ty);
        if (this.modifiedTiles.has(k)) return this.modifiedTiles.get(k);
        return this.baseTileAt(tx, ty);
    }

    setTile(tx, ty, tile) {
        const k = this.key(tx, ty);
        this.modifiedTiles.set(k, tile);
        this.modifiedHp.set(k, TILE_HP[tile] || 0);
    }

    getHp(tx, ty) {
        const k = this.key(tx, ty);
        if (this.modifiedHp.has(k)) return this.modifiedHp.get(k);
        const t = this.getTile(tx, ty);
        return TILE_HP[t] || 0;
    }

    setHp(tx, ty, hp) {
        const k = this.key(tx, ty);
        this.modifiedHp.set(k, hp);
    }

    serializeNear(centerTx, centerTy, maxEntries) {
        const tiles = [];
        const hp = [];
        for (const [k, v] of this.modifiedTiles.entries()) tiles.push([k, v]);
        for (const [k, v] of this.modifiedHp.entries()) hp.push([k, v]);

        const prune = (arr) => {
            if (arr.length <= maxEntries) return arr;
            const scored = arr.map(([k, v]) => {
                const [x, y] = k.split(',').map(n => parseInt(n, 10));
                const d2 = (x - centerTx) * (x - centerTx) + (y - centerTy) * (y - centerTy);
                return { k, v, d2 };
            });
            scored.sort((a, b) => a.d2 - b.d2);
            return scored.slice(0, maxEntries).map(s => [s.k, s.v]);
        };

        return { tiles: prune(tiles), hp: prune(hp) };
    }

    isSolidAt(px, py, radius) {
        const checkTile = (x, y) => {
            const tx = Math.floor(x / TILE_SIZE);
            const ty = Math.floor(y / TILE_SIZE);
            const t = this.getTile(tx, ty);
            return t !== T_FLOOR && t !== T_FORGE && t !== T_CACHE;
        };

        return checkTile(px - radius + 2, py) ||
               checkTile(px + radius - 2, py) ||
               checkTile(px, py - radius + 2) ||
               checkTile(px, py + radius - 2);
    }
}

// --- Main Game Logic ---

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let gameRunning = false;
let game;

class Game {
    constructor(worldSeed) {
        this.resize();
        this.input = new Input();
        this.map = new InfiniteMap(worldSeed);
        this.tileArt = new TileArt(TILE_SIZE);
        this.time = 0;
        this.hoveredTile = null;
        this._grainPattern = this._makeGrainPattern();
        this.effects = [];
        this.shakeMag = 0;
        this.shakeX = 0;
        this.shakeY = 0;
        this.renderCamX = 0;
        this.renderCamY = 0;

        this.audio = new AudioManager();

        this.uiDepth = document.getElementById('ui-depth');
        
        // Spawn player in middle
        const startX = (this.map.spawnTile.x) * TILE_SIZE + TILE_SIZE / 2;
        const startY = (this.map.spawnTile.y) * TILE_SIZE + TILE_SIZE / 2;
        
        this.player = new Player(startX, startY);
        this.camera = new Camera(this.viewportWidth, this.viewportHeight);
        this.particles = [];
        this.floaters = [];
        this.drills = [];
        this.placeDrillMode = false;
        this._mouseWasDown = false;
        
        this.miningTick = 0;
        this.isForgeOpen = false;
        this.isMinesMenuOpen = false;
        this._autosaveTick = 0;

        this.saveSlotId = null;
        try {
            if (typeof SaveManager !== 'undefined' && SaveManager && typeof SaveManager.getCurrentSlotId === 'function') {
                this.saveSlotId = SaveManager.getCurrentSlotId() || (typeof SaveManager.ensureCurrentSlot === 'function' ? SaveManager.ensureCurrentSlot() : null);
            }
        } catch {}
        
        // Listen for interaction key
        window.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'e') this.interact();
            if (e.key.toLowerCase() === 'q') this.togglePlaceDrill();
            if (e.key === 'Escape') {
                const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
                e.preventDefault();
                e.stopPropagation();
                if (this.isForgeOpen) this.closeForge();
                if (window.MinesUi) {
                    if (window.MinesUi.isOpen) window.MinesUi.close();
                    else {
                        if (tag === 'input' || tag === 'textarea' || tag === 'select') return;
                        window.MinesUi.open();
                    }
                }
            }
        });
    }

    _makeGrainPattern() {
        const g = document.createElement('canvas');
        g.width = 128;
        g.height = 128;
        const gctx = g.getContext('2d');
        const img = gctx.createImageData(g.width, g.height);
        for (let i = 0; i < img.data.length; i += 4) {
            const v = Math.floor(Math.random() * 255);
            img.data[i] = v;
            img.data[i + 1] = v;
            img.data[i + 2] = v;
            img.data[i + 3] = 255;
        }
        gctx.putImageData(img, 0, 0);
        return ctx.createPattern(g, 'repeat');
    }
    
    resize() {
        const cssW = window.innerWidth;
        const cssH = window.innerHeight;
        const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));

        this.viewportWidth = cssW;
        this.viewportHeight = cssH;

        canvas.style.width = `${cssW}px`;
        canvas.style.height = `${cssH}px`;
        canvas.width = Math.floor(cssW * dpr);
        canvas.height = Math.floor(cssH * dpr);

        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.imageSmoothingEnabled = true;

        if (this.camera) {
            this.camera.width = cssW;
            this.camera.height = cssH;
        }
    }
    
    interact() {
        const cache = this.findNearbyCache();
        if (cache) {
            this.openCache(cache.tx, cache.ty);
            return;
        }

        // Check distance to forge
        const forgeX = (this.map.forgeTile.x) * TILE_SIZE + TILE_SIZE/2;
        const forgeY = (this.map.forgeTile.y) * TILE_SIZE + TILE_SIZE/2;
        const dist = Math.sqrt((this.player.x - forgeX)**2 + (this.player.y - forgeY)**2);
        
        if (dist < 100) {
            this.openForge();
        }
    }
    
    openForge() {
        this.isForgeOpen = true;
        document.getElementById('forge-menu').style.display = 'block';
        if (window.ForgeUi) ForgeUi.onOpen();
        this.refreshTraderCodeUi();
        this.updateUi();
    }
    
    closeForge() {
        this.isForgeOpen = false;
        document.getElementById('forge-menu').style.display = 'none';
    }

    refreshTraderCodeUi() {
        const input = document.getElementById('forge-code-input');
        const button = document.getElementById('forge-code-btn');
        const status = document.getElementById('forge-code-status');
        if (!input || !button || !status) return;

        const feetUsed = safeGet(TRADER_CODE_USED_KEY) === '1';
        input.disabled = false;
        button.disabled = false;
        status.classList.remove('good', 'bad');
        status.textContent = feetUsed ? 'Tip: The special trader code has already been redeemed.' : 'Codes are case-insensitive.';
    }

    redeemTraderCodeFromUi() {
        const input = document.getElementById('forge-code-input');
        const status = document.getElementById('forge-code-status');
        if (!input || !status) return;

        const raw = String(input.value || '');
        const code = raw.trim();
        if (!code) return;

        const normalized = code.toLowerCase();

        if (normalized === 'hiilikefeet') {
            if (safeGet(TRADER_CODE_USED_KEY) === '1') {
                status.classList.remove('good');
                status.classList.add('bad');
                status.textContent = 'That code was already used.';
                this.refreshTraderCodeUi();
                return;
            }

            this.player.money += 40000;
            safeSet(TRADER_CODE_USED_KEY, '1');
            input.value = '';
            status.classList.remove('bad');
            status.classList.add('good');
            status.textContent = 'Redeemed: +$40,000';
            this.updateUi();
            this.saveProgress();
            this.refreshTraderCodeUi();
            return;
        }

        const codes = loadRedeemableCodes();
        const idx = codes.findIndex((c) => String(c.code).toLowerCase() === normalized);
        if (idx >= 0) {
            const entry = codes[idx];
            if (entry.used) {
                status.classList.remove('good');
                status.classList.add('bad');
                status.textContent = 'That code was already redeemed.';
                return;
            }

            const rewardMoney = Number(entry.money || 0);
            if (Number.isFinite(rewardMoney) && rewardMoney > 0) {
                this.player.money += Math.floor(rewardMoney);
            }
            entry.used = true;
            entry.usedAt = Date.now();
            codes[idx] = entry;
            saveRedeemableCodes(codes);

            input.value = '';
            status.classList.remove('bad');
            status.classList.add('good');
            status.textContent = rewardMoney > 0 ? `Redeemed: +$${Math.floor(rewardMoney).toLocaleString()}` : 'Redeemed.';
            this.updateUi();
            this.saveProgress();
            return;
        }

        status.classList.remove('good');
        status.classList.add('bad');
        status.textContent = 'Invalid code.';
    }

    buyDrillRig() {
        const cost = this.getDrillRigCost();
        if (this.player.money < cost) return;
        this.player.money -= cost;
        this.player.drillRigs++;
        this.updateUi();
        this.saveProgress();
    }

    getDrillRigCost() {
        return Math.floor(250 * (1 + this.player.drillRigs * 0.5));
    }

    togglePlaceDrill() {
        if (!gameRunning) return;
        if (this.isForgeOpen) {
            this.closeForge();
        }
        if (this.player.drillRigs <= 0) {
            this.placeDrillMode = false;
            return;
        }
        this.placeDrillMode = !this.placeDrillMode;
    }
    
    sellAll() {
        let total = 0;
        for (const ore of ORES) {
            total += this.player.inventory[ore.key] * ORE_VALUE[ore.key];
        }
        total = Math.floor(total * this.player.sellMultiplier);
        
        if (total > 0) {
            this.player.money += total;
            for (const ore of ORES) {
                this.player.inventory[ore.key] = 0;
            }
            this.spawnFloater(this.player.x, this.player.y - 20, `+$${total}`, '#50fa7b');
            this.updateUi();
        }
    }
    
    upgradePickaxe() {
        const cost = this.player.levels.pick * 100;
        if (this.player.money >= cost) {
            this.player.money -= cost;
            this.player.miningPower += 2;
            this.player.levels.pick++;
            this.updateUi();
        }
    }

    upgradeBoots() {
        const cost = this.player.levels.boots * 150;
        if (this.player.money >= cost) {
            this.player.money -= cost;
            this.player.maxSpeed += 0.5;
            this.player.levels.boots++;
            this.updateUi();
        }
    }

    upgradeLight() {
        const cost = this.player.levels.light * 200;
        if (this.player.money >= cost) {
            this.player.money -= cost;
            this.player.lightRadius += 30;
            this.player.levels.light++;
            this.updateUi();
        }
    }

    upgradeReach() {
        const cost = this.player.levels.reach * 250;
        if (this.player.money >= cost) {
            this.player.money -= cost;
            this.player.miningRange += 14;
            this.player.levels.reach++;
            this.updateUi();
        }
    }

    upgradeSmelter() {
        const cost = this.player.levels.smelt * 400;
        if (this.player.money >= cost) {
            this.player.money -= cost;
            this.player.sellMultiplier = Math.min(3.0, this.player.sellMultiplier + 0.15);
            this.player.levels.smelt++;
            this.updateUi();
        }
    }

    upgradeLuck() {
        const cost = this.player.levels.luck * 500;
        if (this.player.money >= cost) {
            this.player.money -= cost;
            this.player.luck = Math.min(0.35, this.player.luck + 0.05);
            this.player.levels.luck++;
            this.updateUi();
        }
    }

    upgradeDrill() {
        const cost = this.player.levels.drill * 650;
        if (this.player.money >= cost) {
            this.player.money -= cost;
            this.player.miningInterval = Math.max(2, this.player.miningInterval - 1);
            this.player.levels.drill++;
            this.updateUi();
        }
    }

    upgradeXpBoost() {
        const cost = this.player.levels.xp * 350;
        if (this.player.money >= cost) {
            this.player.money -= cost;
            this.player.xpBoost = Math.min(1.0, this.player.xpBoost + 0.15);
            this.player.levels.xp++;
            this.updateUi();
        }
    }

    upgradeCrit() {
        const cost = this.player.levels.crit * 450;
        if (this.player.money >= cost) {
            this.player.money -= cost;
            this.player.critChance = Math.min(0.35, this.player.critChance + 0.04);
            this.player.levels.crit++;
            this.updateUi();
        }
    }

    upgradeRigCore() {
        const cost = this.player.levels.rigcore * 550;
        if (this.player.money >= cost) {
            this.player.money -= cost;
            this.player.drillInterval = Math.max(6, this.player.drillInterval - 1);
            this.player.drillPower = Math.min(6, this.player.drillPower + 0.25);
            this.player.levels.rigcore++;
            this.updateUi();
        }
    }

    upgradeOreMagnet() {
        const cost = this.player.levels.magnet * 500;
        if (this.player.money >= cost) {
            this.player.money -= cost;
            this.player.oreBonus = Math.min(0.35, this.player.oreBonus + 0.05);
            this.player.levels.magnet++;
            this.updateUi();
        }
    }

    gainXp(amount) {
        if (!Number.isFinite(amount) || amount <= 0) return;
        const gain = Math.max(0, Math.floor(amount * (1 + this.player.xpBoost)));
        if (gain <= 0) return;
        this.player.xp += gain;
        let leveled = false;
        while (this.player.xp >= xpForLevel(this.player.level)) {
            this.player.xp -= xpForLevel(this.player.level);
            this.player.level += 1;
            leveled = true;
        }
        if (leveled) {
            this.spawnFloater(this.player.x, this.player.y - 30, `LEVEL ${this.player.level}`, '#ffd56a');
            showToast(`Level up! Now level ${this.player.level}.`);
        }
        this.updateXpUi();
    }

    updateXpUi() {
        const levelEl = document.getElementById('ui-level');
        const xpEl = document.getElementById('ui-xp');
        const xpNextEl = document.getElementById('ui-xp-next');
        const xpFill = document.getElementById('ui-xp-fill');
        const next = xpForLevel(this.player.level);
        const current = Math.max(0, Math.floor(this.player.xp));
        const pct = next > 0 ? Math.min(1, current / next) : 0;
        if (levelEl) levelEl.textContent = this.player.level;
        if (xpEl) xpEl.textContent = current;
        if (xpNextEl) xpNextEl.textContent = next;
        if (xpFill) xpFill.style.width = `${(pct * 100).toFixed(1)}%`;
    }
    
    update() {
        if (this.isForgeOpen || this.isMinesMenuOpen) return;

        this.player.update(this.input, this.map);
        this.camera.follow(this.player);
        this.time += 1;

        this._updateShake();
        this.renderCamX = this.camera.x + this.shakeX;
        this.renderCamY = this.camera.y + this.shakeY;
        
        // Particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
            this.particles[i].update();
            if (this.particles[i].life <= 0) this.particles.splice(i, 1);
        }

        // Effects
        for (let i = this.effects.length - 1; i >= 0; i--) {
            this.effects[i].update();
            if (this.effects[i].life <= 0) this.effects.splice(i, 1);
        }

        // Floaters
        for (let i = this.floaters.length - 1; i >= 0; i--) {
            this.floaters[i].update();
            if (this.floaters[i].life <= 0) this.floaters.splice(i, 1);
        }
        
        // Mining Logic
        this.hoveredTile = null;
        const mouseEdgeDown = this.input.mouse.down && !this._mouseWasDown;
        this._mouseWasDown = this.input.mouse.down;
        if (this.input.mouse.down) {
            // Convert screen mouse to world mouse
            const mx = this.input.mouse.x + this.renderCamX;
            const my = this.input.mouse.y + this.renderCamY;
            
            const tx = Math.floor(mx / TILE_SIZE);
            const ty = Math.floor(my / TILE_SIZE);
            
            // Distance check (reach)
            const dx = (tx * TILE_SIZE + TILE_SIZE/2) - this.player.x;
            const dy = (ty * TILE_SIZE + TILE_SIZE/2) - this.player.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist < this.player.miningRange) { // Range
                this.hoveredTile = { tx, ty };
                if (this.placeDrillMode && mouseEdgeDown) {
                    this.tryPlaceDrill(tx, ty);
                } else if (!this.placeDrillMode) {
                    this.mineTile(tx, ty, mx, my);
                }
            }
        }

        // Drills
        for (const d of this.drills) d.update(this);
        
        // Forge Interaction Hint
        const forgeX = (this.map.forgeTile.x) * TILE_SIZE + TILE_SIZE/2;
        const forgeY = (this.map.forgeTile.y) * TILE_SIZE + TILE_SIZE/2;
        const distToForge = Math.sqrt((this.player.x - forgeX)**2 + (this.player.y - forgeY)**2);
        const msgArea = document.getElementById('message-area');
        const nearbyCache = this.findNearbyCache();
        if (this.placeDrillMode) {
            msgArea.textContent = `Place drill: click wall/ore (${this.player.drillRigs} left)`;
            msgArea.style.opacity = 1;
        } else if (nearbyCache) {
            msgArea.textContent = 'Tap or press E to open cache';
            msgArea.style.opacity = 1;
        } else if (distToForge < 100) {
            msgArea.textContent = 'Tap or press E to interact';
            msgArea.style.opacity = 1;
        } else {
            msgArea.style.opacity = 0;
        }

        if (this.uiDepth && this.time % 10 === 0) this.uiDepth.innerText = `${this.getDepth()}m`;

        this.audio.setForgeHum(distToForge < 160);

        this._autosaveTick++;
        if (this._autosaveTick % 120 === 0) this.saveProgress(); // ~ every 2s at 60fps
    }

    tryPlaceDrill(tx, ty) {
        if (this.player.drillRigs <= 0) return false;
        const tile = this.map.getTile(tx, ty);
        if (tile === T_FLOOR || tile === T_BEDROCK || tile === T_FORGE || tile === T_CACHE) return false;
        this.player.drillRigs--;
        this.placeDrillMode = false;
        this.drills.push(new DrillRig(tx, ty));
        const x = tx * TILE_SIZE + TILE_SIZE / 2;
        const y = ty * TILE_SIZE + TILE_SIZE / 2;
        this.effects.push(new Shockwave(x, y, 'rgba(255,176,32,0.95)', 28, 16));
        this.addShake(3);
        this.updateUi();
        this.saveProgress();
        return true;
    }

    _updateShake() {
        this.shakeMag *= 0.88;
        if (this.shakeMag < 0.05) {
            this.shakeMag = 0;
            this.shakeX = 0;
            this.shakeY = 0;
            return;
        }
        this.shakeX = (Math.random() - 0.5) * 2 * this.shakeMag;
        this.shakeY = (Math.random() - 0.5) * 2 * this.shakeMag;
    }

    addShake(amount) {
        this.shakeMag = Math.min(18, this.shakeMag + amount);
    }

    getDepth() {
        const ty = Math.floor(this.player.y / TILE_SIZE);
        return Math.max(0, ty - this.map.spawnTile.y);
    }

    findNearbyCache() {
        const ptx = Math.floor(this.player.x / TILE_SIZE);
        const pty = Math.floor(this.player.y / TILE_SIZE);
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                const tx = ptx + dx;
                const ty = pty + dy;
                if (this.map.getTile(tx, ty) !== T_CACHE) continue;
                const cx = tx * TILE_SIZE + TILE_SIZE / 2;
                const cy = ty * TILE_SIZE + TILE_SIZE / 2;
                const dist = Math.hypot(this.player.x - cx, this.player.y - cy);
                if (dist < 70) return { tx, ty, dist };
            }
        }
        return null;
    }

    openCache(tx, ty) {
        if (this.map.getTile(tx, ty) !== T_CACHE) return;
        this.map.setTile(tx, ty, T_FLOOR);

        const x = tx * TILE_SIZE + TILE_SIZE / 2;
        const y = ty * TILE_SIZE + TILE_SIZE / 2;
        this.effects.push(new Shockwave(x, y, COLORS[T_CACHE], 44, 22));
        for (let i = 0; i < 18; i++) this.particles.push(new Particle(x, y, COLORS[T_CACHE], 4.2, 46));
        this.addShake(6);
        this.audio.playCacheOpen();

        const depth = this.getDepth();
        const tier = depth < 20 ? ['coal', 'iron', 'gold'] :
            depth < 55 ? ['coal', 'iron', 'gold', 'diamond', 'topaz'] :
            depth < 90 ? ['iron', 'gold', 'diamond', 'emerald', 'ruby', 'topaz', 'opal'] :
            depth < 130 ? ['gold', 'diamond', 'emerald', 'ruby', 'sapphire', 'amethyst', 'opal', 'titanium', 'platinum'] :
            ['diamond', 'emerald', 'ruby', 'sapphire', 'amethyst', 'topaz', 'opal', 'titanium', 'platinum', 'obsidian', 'jade', 'onyx', 'mythril', 'celestite', 'voidstone'];

        const picks = 2 + (Math.random() < 0.35 ? 1 : 0);
        for (let i = 0; i < picks; i++) {
            const key = tier[Math.floor(Math.random() * tier.length)];
            this.player.inventory[key] += 1;
            this.spawnFloater(x - 18 + i * 10, y - 8 - i * 10, `+1 ${key.toUpperCase()}`, COLORS[this._tileForInvKey(key)] || COLORS[T_CACHE]);
        }
        const cash = 25 + Math.floor(Math.random() * (30 + depth * 2));
        this.player.money += cash;
        this.spawnFloater(x - 10, y - 34, `+$${cash}`, '#32d583');

        if (Math.random() < 0.28) {
            const codes = loadRedeemableCodes();
            if (codes.filter((c) => !c.used).length < 12) {
                let newCode = generateRedeemCode();
                const seen = new Set(codes.map((c) => String(c.code).toLowerCase()));
                while (seen.has(newCode.toLowerCase())) newCode = generateRedeemCode();

                const rewardMoney = 120 + Math.floor(depth * 6 + Math.random() * 160);
                codes.push({ code: newCode, money: rewardMoney, used: false, createdAt: Date.now(), source: 'cache' });
                saveRedeemableCodes(codes);

                this.spawnFloater(x - 26, y - 56, `CODE: ${newCode}`, COLORS[T_CACHE]);
                showToast(`Found a trader code: ${newCode} (Forge → Codes)`);
            }
        }

        this.updateUi();
    }

    _tileForInvKey(key) {
        const ore = ORE_BY_KEY[key];
        return ore ? ore.tile : T_CACHE;
    }
    
    mineTile(tx, ty, worldX, worldY) {
        const type = this.map.getTile(tx, ty);
        
        if (type !== T_FLOOR && type !== T_BEDROCK && type !== T_FORGE && type !== T_CACHE) {
            this.miningTick++;
            if (this.miningTick % this.player.miningInterval === 0) { // Visual shake or particle trigger frequency
                // Particles
                const c = COLORS[type] || '#fff';
                for (let i=0; i<4; i++) this.particles.push(new Particle(worldX, worldY, c, 2.4, 22));
                this.effects.push(new Shockwave(worldX, worldY, c, 18, 14));
                this.addShake(1.4);
                this.audio.playMineHit(type);
                this.player.pulseMine();
                
                // Damage
                const crit = this.player.critChance > 0 && Math.random() < this.player.critChance;
                const damage = crit ? this.player.miningPower * this.player.critMultiplier : this.player.miningPower;
                const hp = this.map.getHp(tx, ty) - damage;
                this.map.setHp(tx, ty, hp);
                
                // Break
                if (hp <= 0) {
                    this.breakTile(tx, ty, type);
                }
            }
        }
    }
    
    breakTile(tx, ty, type) {
        this.map.setTile(tx, ty, T_FLOOR);
        
        // Big particles
        for (let i=0; i<10; i++) {
            this.particles.push(new Particle(
                tx*TILE_SIZE + TILE_SIZE/2, 
                ty*TILE_SIZE + TILE_SIZE/2, 
                COLORS[type], 4, 40
            ));
        }
        this.effects.push(new Shockwave(tx*TILE_SIZE + TILE_SIZE/2, ty*TILE_SIZE + TILE_SIZE/2, COLORS[type] || '#fff', 54, 22));
        this.addShake(5.5);
        this.audio.playMineBreak(type);
        
        // Loot
        let item = null;
        const ore = ORE_BY_TILE[type];
        if (ore) {
            this.player.inventory[ore.key] += 1;
            item = ore.name;
        }
        
        if (item) {
            this.spawnFloater(tx*TILE_SIZE, ty*TILE_SIZE, `+1 ${item}`, COLORS[type]);
            const bonusChance = Math.min(0.4, this.player.luck * 0.35 + this.player.oreBonus);
            if (bonusChance > 0 && Math.random() < bonusChance) {
                this.player.inventory[ore.key] += 1;
                this.spawnFloater(tx*TILE_SIZE, ty*TILE_SIZE - 14, `BONUS +1`, COLORS[type]);
            }
            this.updateUi();
        }
        const xpGain = ore ? ore.xp : 1;
        if (xpGain > 0) this.gainXp(xpGain);
    }
    
    spawnFloater(x, y, text, color) {
        this.floaters.push(new Floater(x, y, text, color));
    }
    
    updateUi() {
        document.getElementById('ui-money').innerText = this.player.money;
        document.getElementById('ui-drills').innerText = this.player.drillRigs;
        for (const ore of ORES) {
            const uiEl = document.getElementById(`ui-${ore.key}`);
            if (uiEl) uiEl.innerText = this.player.inventory[ore.key];
        }

        const sellPreview = this.getSellPreview();
        document.getElementById('ui-sell-preview').innerText = `$${sellPreview}`;
        document.getElementById('ui-money-menu').innerText = this.player.money;
        document.getElementById('ui-smelt-mult').innerText = `${this.player.sellMultiplier.toFixed(2)}×`;
        for (const ore of ORES) {
            const uiMenuEl = document.getElementById(`ui-${ore.key}-menu`);
            if (uiMenuEl) uiMenuEl.innerText = this.player.inventory[ore.key];
        }
        
        // Update Shop Costs
        document.getElementById('cost-pick').innerText = `$${this.player.levels.pick * 100}`;
        document.getElementById('cost-boots').innerText = `$${this.player.levels.boots * 150}`;
        document.getElementById('cost-light').innerText = `$${this.player.levels.light * 200}`;
        document.getElementById('cost-reach').innerText = `$${this.player.levels.reach * 250}`;
        document.getElementById('cost-smelt').innerText = `$${this.player.levels.smelt * 400}`;
        document.getElementById('cost-luck').innerText = `$${this.player.levels.luck * 500}`;
        document.getElementById('cost-drill').innerText = `$${this.player.levels.drill * 650}`;
        document.getElementById('cost-xp').innerText = `$${this.player.levels.xp * 350}`;
        document.getElementById('cost-crit').innerText = `$${this.player.levels.crit * 450}`;
        document.getElementById('cost-rigcore').innerText = `$${this.player.levels.rigcore * 550}`;
        document.getElementById('cost-magnet').innerText = `$${this.player.levels.magnet * 500}`;
        document.getElementById('cost-rig').innerText = `$${this.getDrillRigCost()}`;
        
        // Enable/Disable buttons
        document.getElementById('btn-upg-pick').disabled = this.player.money < this.player.levels.pick * 100;
        document.getElementById('btn-upg-boots').disabled = this.player.money < this.player.levels.boots * 150;
        document.getElementById('btn-upg-light').disabled = this.player.money < this.player.levels.light * 200;
        document.getElementById('btn-upg-reach').disabled = this.player.money < this.player.levels.reach * 250;
        document.getElementById('btn-upg-smelt').disabled = this.player.money < this.player.levels.smelt * 400;
        document.getElementById('btn-upg-luck').disabled = this.player.money < this.player.levels.luck * 500;
        document.getElementById('btn-upg-drill').disabled = this.player.money < this.player.levels.drill * 650;
        document.getElementById('btn-upg-xp').disabled = this.player.money < this.player.levels.xp * 350;
        document.getElementById('btn-upg-crit').disabled = this.player.money < this.player.levels.crit * 450;
        document.getElementById('btn-upg-rigcore').disabled = this.player.money < this.player.levels.rigcore * 550;
        document.getElementById('btn-upg-magnet').disabled = this.player.money < this.player.levels.magnet * 500;
        document.getElementById('btn-buy-rig').disabled = this.player.money < this.getDrillRigCost();
        this.updateXpUi();
    }

    getSellPreview() {
        let total = 0;
        for (const ore of ORES) {
            total += this.player.inventory[ore.key] * ORE_VALUE[ore.key];
        }
        return Math.floor(total * this.player.sellMultiplier);
    }

    getSaveState() {
        const tx = Math.floor(this.player.x / TILE_SIZE);
        const ty = Math.floor(this.player.y / TILE_SIZE);
        const mapState = this.map.serializeNear(tx, ty, 12000);
        return {
            v: 1,
            ts: Date.now(),
            worldSeed: this.map.seed >>> 0,
            player: {
                x: this.player.x,
                y: this.player.y,
                money: this.player.money,
                inventory: this.player.inventory,
                level: this.player.level,
                xp: this.player.xp,
                drillRigs: this.player.drillRigs,
                miningPower: this.player.miningPower,
                lightRadius: this.player.lightRadius,
                maxSpeed: this.player.maxSpeed,
                miningRange: this.player.miningRange,
                miningInterval: this.player.miningInterval,
                sellMultiplier: this.player.sellMultiplier,
                luck: this.player.luck,
                xpBoost: this.player.xpBoost,
                critChance: this.player.critChance,
                critMultiplier: this.player.critMultiplier,
                drillPower: this.player.drillPower,
                drillInterval: this.player.drillInterval,
                oreBonus: this.player.oreBonus,
                levels: this.player.levels
            },
            map: mapState,
            drills: this.drills.map(d => ({ tx: d.tx, ty: d.ty }))
        };
    }

    applySaveState(state) {
        if (!state || state.v !== 1) return false;
        if (Number.isFinite(state.worldSeed) && this.map && typeof this.map.setSeed === 'function') {
            this.map.setSeed(state.worldSeed >>> 0);
        }
        const p = state.player;
        if (p && Number.isFinite(p.x) && Number.isFinite(p.y)) {
            this.player.x = p.x;
            this.player.y = p.y;
            this.player.money = Number.isFinite(p.money) ? p.money : 0;
            this.player.inventory = normalizeInventory(p.inventory);
            this.player.level = Number.isFinite(p.level) ? Math.max(1, Math.floor(p.level)) : this.player.level;
            this.player.xp = Number.isFinite(p.xp) ? Math.max(0, Math.floor(p.xp)) : this.player.xp;
            this.player.drillRigs = Number.isFinite(p.drillRigs) ? p.drillRigs : 0;
            this.player.miningPower = Number.isFinite(p.miningPower) ? p.miningPower : this.player.miningPower;
            this.player.lightRadius = Number.isFinite(p.lightRadius) ? p.lightRadius : this.player.lightRadius;
            this.player.maxSpeed = Number.isFinite(p.maxSpeed) ? p.maxSpeed : this.player.maxSpeed;
            this.player.miningRange = Number.isFinite(p.miningRange) ? p.miningRange : this.player.miningRange;
            this.player.miningInterval = Number.isFinite(p.miningInterval) ? p.miningInterval : this.player.miningInterval;
            this.player.sellMultiplier = Number.isFinite(p.sellMultiplier) ? p.sellMultiplier : this.player.sellMultiplier;
            this.player.luck = Number.isFinite(p.luck) ? p.luck : this.player.luck;
            this.player.xpBoost = Number.isFinite(p.xpBoost) ? p.xpBoost : this.player.xpBoost;
            this.player.critChance = Number.isFinite(p.critChance) ? p.critChance : this.player.critChance;
            this.player.critMultiplier = Number.isFinite(p.critMultiplier) ? p.critMultiplier : this.player.critMultiplier;
            this.player.drillPower = Number.isFinite(p.drillPower) ? p.drillPower : this.player.drillPower;
            this.player.drillInterval = Number.isFinite(p.drillInterval) ? p.drillInterval : this.player.drillInterval;
            this.player.oreBonus = Number.isFinite(p.oreBonus) ? p.oreBonus : this.player.oreBonus;
            this.player.levels = normalizeLevels(p.levels);
            while (this.player.xp >= xpForLevel(this.player.level)) {
                this.player.xp -= xpForLevel(this.player.level);
                this.player.level += 1;
            }
        }
        const m = state.map;
        if (m && Array.isArray(m.tiles) && Array.isArray(m.hp)) {
            this.map.modifiedTiles = new Map(m.tiles);
            this.map.modifiedHp = new Map(m.hp);
        }
        if (Array.isArray(state.drills)) {
            this.drills = state.drills
                .filter(d => Number.isFinite(d.tx) && Number.isFinite(d.ty))
                .map(d => new DrillRig(d.tx, d.ty));
        }
        this.updateUi();
        return true;
    }

    saveProgress() {
        const state = this.getSaveState();
        if (this.saveSlotId) SaveManager.saveToSlot(this.saveSlotId, state);
        else SaveManager.save(state);
    }
    
    draw() {
        // Clear background
        ctx.fillStyle = ART.bg1;
        ctx.fillRect(0, 0, this.viewportWidth, this.viewportHeight);
        
        // Calculate Visible Range
        const startCol = Math.floor(this.camera.x / TILE_SIZE);
        const endCol = startCol + (this.viewportWidth / TILE_SIZE) + 2;
        const startRow = Math.floor(this.camera.y / TILE_SIZE);
        const endRow = startRow + (this.viewportHeight / TILE_SIZE) + 2;
        
        const camX = Math.floor(this.renderCamX);
        const camY = Math.floor(this.renderCamY);

        // Draw Map
        for (let y = startRow; y <= endRow; y++) {
            for (let x = startCol; x <= endCol; x++) {
                {
                    const tile = this.map.getTile(x, y);
                    const drawX = x * TILE_SIZE - camX;
                    const drawY = y * TILE_SIZE - camY;
                    
                    if (tile === T_FORGE) {
                        // Forge tile base
                        ctx.drawImage(this.tileArt.get(T_FLOOR, x, y), drawX, drawY);

                        // Forge body
                        ctx.save();
                        const glowPulse = 0.6 + 0.4 * Math.sin(this.time * 0.08);
                        ctx.shadowColor = ART.forgeHot;
                        ctx.shadowBlur = 22;
                        ctx.fillStyle = 'rgba(20,20,28,0.95)';
                        roundRectPath(ctx, drawX + 8, drawY + 10, TILE_SIZE - 16, TILE_SIZE - 14, 10);
                        ctx.fill();

                        // Mouth
                        const mg = ctx.createLinearGradient(0, drawY + 22, 0, drawY + TILE_SIZE - 8);
                        mg.addColorStop(0, `rgba(255,77,109,${0.10 + 0.18 * glowPulse})`);
                        mg.addColorStop(1, `rgba(255,176,32,${0.16 + 0.22 * glowPulse})`);
                        ctx.shadowBlur = 0;
                        ctx.fillStyle = mg;
                        roundRectPath(ctx, drawX + 14, drawY + 26, TILE_SIZE - 28, TILE_SIZE - 36, 8);
                        ctx.fill();

                        // Ember
                        ctx.shadowColor = ART.forgeHot;
                        ctx.shadowBlur = 26;
                        ctx.fillStyle = `rgba(255,176,32,${0.5 + 0.4 * glowPulse})`;
                        ctx.beginPath();
                        ctx.arc(drawX + TILE_SIZE / 2, drawY + TILE_SIZE - 18, 5 + 2 * glowPulse, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    } else {
                        const artType = (tile === T_BEDROCK) ? T_BEDROCK : tile;
                        ctx.drawImage(this.tileArt.get(artType, x, y), drawX, drawY);
                        
                        // Cracks based on HP
                        if (TILE_HP[tile]) {
                            const maxHp = TILE_HP[tile];
                            const currentHp = this.map.getHp(x, y);
                            const dmg = clamp01(1 - currentHp / maxHp);
                            if (dmg > 0.02) {
                                ctx.save();
                                ctx.globalAlpha = Math.min(0.85, dmg + 0.15);
                                ctx.strokeStyle = 'rgba(0,0,0,0.85)';
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.moveTo(drawX + 10, drawY + 10);
                                ctx.lineTo(drawX + 22, drawY + 26);
                                if (dmg > 0.45) {
                                    ctx.lineTo(drawX + 34, drawY + 14);
                                    ctx.moveTo(drawX + 18, drawY + 30);
                                    ctx.lineTo(drawX + 30, drawY + 36);
                                }
                                ctx.stroke();
                                ctx.restore();
                            }
                        }
                    }
                }
            }
        }

        // Mining highlight (visual only)
        if (this.hoveredTile) {
            const { tx, ty } = this.hoveredTile;
            {
                const tile = this.map.getTile(tx, ty);
                if (tile !== T_FLOOR && tile !== T_BEDROCK && tile !== T_FORGE && tile !== T_CACHE) {
                    const x0 = tx * TILE_SIZE - camX;
                    const y0 = ty * TILE_SIZE - camY;
                    const maxHp = TILE_HP[tile] || 1;
                    const hp = this.map.getHp(tx, ty) || maxHp;
                    const t = clamp01(1 - hp / maxHp);

                    ctx.save();
                    ctx.globalAlpha = 0.9;
                    ctx.shadowColor = COLORS[tile] || '#fff';
                    ctx.shadowBlur = 16;
                    ctx.strokeStyle = `rgba(255,255,255,${0.22 + 0.25 * t})`;
                    ctx.lineWidth = 2;
                    roundRectPath(ctx, x0 + 3, y0 + 3, TILE_SIZE - 6, TILE_SIZE - 6, 10);
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    // Progress arc
                    ctx.globalAlpha = 0.9;
                    ctx.strokeStyle = COLORS[tile] || '#fff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(x0 + TILE_SIZE / 2, y0 + TILE_SIZE / 2, 16, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * t);
                    ctx.stroke();
                    ctx.restore();
                }
            }
        }
        
        // Draw Player
        this.player.draw(ctx, camX, camY, this.time);

        // Drills
        for (const d of this.drills) d.draw(ctx, camX, camY, this.time);

        // Effects
        this.effects.forEach(e => e.draw(ctx, camX, camY));

        // Particles
        this.particles.forEach(p => p.draw(ctx, camX, camY));
        this.floaters.forEach(f => f.draw(ctx, camX, camY));
        
        // Lighting Mask
        // We draw a giant black rectangle over everything, then punch a hole in it
        
        // Create an offscreen canvas or just use a radial gradient
        // Since we are single file and performance matters, let's use a big radial gradient centered on player
        
        const screenPx = this.player.x - camX;
        const screenPy = this.player.y - camY;
        
        // Fill canvas with darkness
        const gradient = ctx.createRadialGradient(screenPx, screenPy, 30, screenPx, screenPy, this.player.lightRadius);
        gradient.addColorStop(0, 'rgba(0,0,0,0)');
        gradient.addColorStop(0.8, 'rgba(0,0,0,0.6)');
        gradient.addColorStop(1, 'rgba(0,0,0,0.98)'); // Very dark
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, this.viewportWidth, this.viewportHeight);

        // Vignette
        const vw = this.viewportWidth;
        const vh = this.viewportHeight;
        const vignette = ctx.createRadialGradient(vw / 2, vh / 2, Math.min(vw, vh) * 0.22, vw / 2, vh / 2, Math.max(vw, vh) * 0.78);
        vignette.addColorStop(0, 'rgba(0,0,0,0)');
        vignette.addColorStop(1, 'rgba(0,0,0,0.35)');
        ctx.fillStyle = vignette;
        ctx.fillRect(0, 0, vw, vh);

        // Film grain
        ctx.save();
        ctx.globalAlpha = 0.05;
        ctx.fillStyle = this._grainPattern;
        ctx.fillRect(0, 0, vw, vh);
        ctx.restore();

        this.drawForgeCompass();
    }

    drawForgeCompass() {
        const forgeX = (this.map.forgeTile.x) * TILE_SIZE + TILE_SIZE / 2;
        const forgeY = (this.map.forgeTile.y) * TILE_SIZE + TILE_SIZE / 2;
        const vx = forgeX - this.player.x;
        const vy = forgeY - this.player.y;
        const dist = Math.hypot(vx, vy);
        if (dist < 140) return;

        const angle = Math.atan2(vy, vx);
        const x = this.viewportWidth - 56;
        const y = 66;

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.globalAlpha = 0.92;
        ctx.shadowColor = ART.forgeHot;
        ctx.shadowBlur = 16;
        ctx.fillStyle = 'rgba(255,77,109,0.95)';
        ctx.beginPath();
        ctx.moveTo(16, 0);
        ctx.lineTo(-10, -9);
        ctx.lineTo(-6, 0);
        ctx.lineTo(-10, 9);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 0.75;
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.beginPath();
        ctx.moveTo(10, 0);
        ctx.lineTo(-2, -4);
        ctx.lineTo(-2, 4);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }
}

// --- Init ---

function interactAction() {
    if (!game) return;
    game.audio.ensure();
    game.interact();
}

function loop() {
    if (!gameRunning) return;
    
    game.update();
    game.draw();
    
    requestAnimationFrame(loop);
}

window.addEventListener('resize', () => {
    if (game) game.resize();
});

window.addEventListener('beforeunload', () => {
    if (game) game.saveProgress();
});

function fmtTime(ts) {
    if (!ts) return '';
    const d = new Date(ts);
    return d.toLocaleString([], { month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' });
}

window.ForgeUi = {
    tab: 'sell',
    init() {
        const stored = SaveManager._safeReadJson('ogforge-ui-v1');
        if (stored && typeof stored.tab === 'string') this.tab = stored.tab;

        const tabs = Array.from(document.querySelectorAll('.forge-tab'));
        const allowed = tabs.map(t => t.dataset.tab || '').filter(Boolean);
        if (!allowed.includes(this.tab)) this.tab = allowed[0] || 'sell';
        for (const t of tabs) {
            t.addEventListener('click', () => this.setTab(t.dataset.tab || 'sell'));
        }

        const codeInput = document.getElementById('forge-code-input');
        if (codeInput) {
            codeInput.addEventListener('keydown', (e) => {
                if (e.key !== 'Enter') return;
                e.preventDefault();
                try { if (window.game && typeof window.game.redeemTraderCodeFromUi === 'function') window.game.redeemTraderCodeFromUi(); } catch {}
            });
        }

        this.setTab(this.tab);
        this.refreshMineLabel();
    },
    persist() {
        SaveManager._safeWriteJson('ogforge-ui-v1', { tab: this.tab });
    },
    setTab(name) {
        this.tab = name;
        const tabs = Array.from(document.querySelectorAll('.forge-tab'));
        const panels = Array.from(document.querySelectorAll('.forge-tab-panel'));
        for (const t of tabs) t.classList.toggle('active', (t.dataset.tab || '') === name);
        for (const p of panels) p.classList.toggle('active', (p.dataset.panel || '') === name);
        this.persist();
    },
    onOpen() {
        this.refreshMineLabel();
        this.setTab(this.tab);
        try { if (window.game && typeof window.game.refreshTraderCodeUi === 'function') window.game.refreshTraderCodeUi(); } catch {}
    },
    refreshMineLabel() {
        const el = document.getElementById('ui-mine-name');
        if (!el) return;
        const slot = SaveManager.getCurrentSlot();
        el.textContent = slot?.name || 'Mine';
    }
};

SaveManager.renameSlot = function renameSlot(id, name) {
    const trimmed = (name || '').trim().slice(0, 24);
    if (!trimmed) return false;
    return this._touchSlotMeta(id, { name: trimmed, updatedAt: Date.now() });
};

window.MinesUi = {
    isOpen: false,
    init() {
        this.root = document.getElementById('esc-menu');
        this.list = document.getElementById('esc-mines-list');
        this.mineName = document.getElementById('esc-mine-name');
        this.savePath = document.getElementById('esc-save-path');
        this.refresh();
    },
    open() {
        this.isOpen = true;
        if (game) game.isMinesMenuOpen = true;
        if (this.root) {
            this.root.style.display = 'block';
            this.root.setAttribute('aria-hidden', 'false');
        }
        this.refresh();
    },
    close() {
        this.isOpen = false;
        if (game) game.isMinesMenuOpen = false;
        if (this.root) {
            this.root.style.display = 'none';
            this.root.setAttribute('aria-hidden', 'true');
        }
    },
    toggle() {
        if (this.isOpen) this.close();
        else this.open();
    },
    refresh() {
        const slot = SaveManager.getCurrentSlot();
        if (this.mineName) this.mineName.textContent = slot?.name || 'Mine';

        if (this.savePath) {
            let msg = 'Saves on this computer.';
            try {
                if (window.ogforgeStore && typeof window.ogforgeStore.getSavesDir === 'function') {
                    const dir = window.ogforgeStore.getSavesDir();
                    if (dir) msg = `Saves folder: ${dir}`;
                }
            } catch {}
            this.savePath.textContent = msg;
        }

        if (!this.list) return;
        this.list.innerHTML = '';

        const slots = SaveManager.listSlots();
        const current = SaveManager.getCurrentSlotId();
        for (const s of slots) {
            const row = document.createElement('div');
            row.className = 'mine-item';

            const left = document.createElement('div');
            const name = document.createElement('div');
            name.className = 'name';
            name.textContent = s.name || 'Mine';
            const meta = document.createElement('div');
            meta.className = 'meta';
            meta.textContent = `Last saved: ${fmtTime(s.updatedAt || s.createdAt)}`;
            left.appendChild(name);
            left.appendChild(meta);

            const actions = document.createElement('div');
            actions.className = 'mine-actions';

            const renameBtn = document.createElement('button');
            renameBtn.className = 'btn btn-mini';
            renameBtn.type = 'button';
            renameBtn.textContent = 'Rename';
            renameBtn.addEventListener('click', () => {
                const next = prompt('Rename mine:', s.name || 'Mine');
                if (!next) return;
                SaveManager.renameSlot(s.id, next);
                this.refresh();
                if (window.ForgeUi) ForgeUi.refreshMineLabel();
            });
            actions.appendChild(renameBtn);

            if (s.id === current) {
                const currentBtn = document.createElement('button');
                currentBtn.className = 'btn btn-mini';
                currentBtn.type = 'button';
                currentBtn.disabled = true;
                currentBtn.textContent = 'Current';
                actions.appendChild(currentBtn);
            } else {
                const switchBtn = document.createElement('button');
                switchBtn.className = 'btn btn-mini primary';
                switchBtn.type = 'button';
                switchBtn.textContent = 'Switch';
                switchBtn.addEventListener('click', () => switchMine(s.id));
                actions.appendChild(switchBtn);
            }

            row.appendChild(left);
            row.appendChild(actions);
            this.list.appendChild(row);
        }
    }
};

function switchMine(id) {
    if (game) game.saveProgress();
    const ok = SaveManager.setCurrentSlotId(id);
    if (!ok) {
        alert('Could not switch mine (save index error).');
        return;
    }
    window.location.reload();
}

function createNewMine() {
    if (game) game.saveProgress();
    const input = document.getElementById('esc-new-mine-name') || document.getElementById('new-mine-name');
    const name = input ? input.value : '';
    SaveManager.createSlot(name);
    window.location.reload();
}

function bootGame() {
    SaveManager.ensureCurrentSlot();
    OreUi.init();
    ForgeUi.init();
    MinesUi.init();
    const save = SaveManager.load();
    const slot = SaveManager.getCurrentSlot();
    const seed = (save && Number.isFinite(save.worldSeed)) ? (save.worldSeed >>> 0) : (slot && Number.isFinite(slot.seed) ? (slot.seed >>> 0) : 0);
    game = new Game(seed);
    if (save) game.applySaveState(save);
    game.updateUi();
    gameRunning = true;
    requestAnimationFrame(loop);

    const toast = document.getElementById('boot-toast');
    if (toast) {
        toast.style.opacity = '1';
        window.setTimeout(() => (toast.style.opacity = '0'), 4200);
    }
}

bootGame();

</script>
</body>
</html>
