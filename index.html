 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>OGforge</title>
    <style>
        :root{
            --bg-0:#07070a;
            --bg-1:#0c0c12;
            --panel:rgba(18,18,26,.72);
            --panel-strong:rgba(18,18,26,.9);
            --border:rgba(255,255,255,.10);
            --text:#eef0ff;
            --muted:rgba(238,240,255,.72);
            --accent:#ff4d6d;
            --accent-2:#7c5cff;
            --good:#32d583;
            --warn:#ffb020;
            --cyan:#39e6ff;
        }

        body {
            margin: 0;
            overflow: hidden;
            background:
                radial-gradient(1200px 900px at 65% 35%, rgba(124,92,255,.18), transparent 55%),
                radial-gradient(1000px 800px at 30% 70%, rgba(255,77,109,.12), transparent 60%),
                linear-gradient(180deg, var(--bg-0), var(--bg-1));
            color: var(--text);
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
            touch-action: none; /* Prevent zoom/scroll on mobile */
        }

        #gameCanvas {
            display: block;
            position: fixed;
            inset: 0;
            width: 100vw;
            height: 100vh;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 14px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.55), transparent);
            gap: 12px;
        }

        .stats-box {
            background: linear-gradient(180deg, rgba(24,24,36,.80), rgba(16,16,24,.65));
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 10px 14px;
            pointer-events: auto;
            min-width: 120px;
            backdrop-filter: blur(10px);
            box-shadow:
                0 10px 30px rgba(0,0,0,.35),
                inset 0 1px 0 rgba(255,255,255,.08);
        }

        .stat-row {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 13px;
            font-weight: 700;
            letter-spacing: .2px;
        }

        .stat-row img, .stat-icon {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            display: inline-block;
            border-radius: 50%;
            box-shadow: 0 0 0 1px rgba(255,255,255,.12), 0 6px 18px rgba(0,0,0,.35);
        }

        .money { color: var(--good); }
        .ore-coal { color: rgba(238,240,255,.78); }
        .ore-iron { color: #ffb86c; }
        .ore-gold { color: #ffd56a; }
        .ore-diamond { color: var(--cyan); }

        #forge-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(180deg, rgba(22,22,34,.92), rgba(14,14,22,.92));
            border: 1px solid rgba(255,77,109,.45);
            border-radius: 18px;
            padding: 20px;
            width: 90%;
            max-width: 400px;
            text-align: center;
            display: none; /* Hidden by default */
            pointer-events: auto;
            box-shadow:
                0 28px 70px rgba(0,0,0,0.65),
                inset 0 1px 0 rgba(255,255,255,0.08);
            backdrop-filter: blur(10px);
        }

        #forge-menu h2 {
            margin-top: 0;
            color: rgba(255,255,255,.95);
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
            font-size: 18px;
            letter-spacing: .7px;
            text-transform: uppercase;
        }

        .btn {
            background: linear-gradient(180deg, rgba(60,60,80,.85), rgba(40,40,58,.85));
            border: 1px solid rgba(255,255,255,.10);
            color: white;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
            width: 100%;
            text-align: left;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 12px 26px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.08);
        }

        .btn:hover { transform: translateY(-1px); border-color: rgba(255,255,255,.18); }
        .btn:active { transform: translateY(0px) scale(.99); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-action {
            background: linear-gradient(180deg, rgba(255,77,109,.95), rgba(255,77,109,.78));
            border-color: rgba(255,77,109,.55);
            text-align: center;
            justify-content: center;
        }
        .btn-action:hover { filter: brightness(1.05); }
        .btn-close {
            background: linear-gradient(180deg, rgba(30,30,44,.92), rgba(18,18,28,.92));
            margin-top: 15px;
            text-align: center;
            justify-content: center;
        }

        #message-area {
            position: absolute;
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: auto;
            cursor: pointer;
            font-weight: bold;
            text-shadow: 0 6px 20px rgba(0,0,0,.8);
            font-size: 14px;
            letter-spacing: .4px;
            opacity: 0;
            transition: opacity 0.5s;
            padding: 10px 14px;
            border-radius: 999px;
            background: rgba(10,10,16,.38);
            border: 1px solid rgba(255,255,255,.10);
            backdrop-filter: blur(10px);
        }

        /* Introduction Modal */
        #intro-modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background:
                radial-gradient(1200px 800px at 50% 30%, rgba(124,92,255,.25), transparent 60%),
                radial-gradient(900px 700px at 50% 70%, rgba(255,77,109,.18), transparent 65%),
                rgba(0,0,0,0.88);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
            text-align: center;
            padding: 18px;
        }

        #intro-content {
            background: linear-gradient(180deg, rgba(24,24,36,.92), rgba(14,14,22,.92));
            padding: 34px;
            border-radius: 20px;
            border: 1px solid rgba(124,92,255,.50);
            max-width: 500px;
            box-shadow: 0 40px 90px rgba(0,0,0,.65), inset 0 1px 0 rgba(255,255,255,.08);
            backdrop-filter: blur(12px);
            position: relative;
            overflow: hidden;
        }

        #intro-content::before{
            content:"";
            position:absolute;
            inset:-2px;
            background:
                radial-gradient(600px 220px at 30% 0%, rgba(57,230,255,.10), transparent 55%),
                radial-gradient(700px 260px at 70% 100%, rgba(255,77,109,.12), transparent 60%);
            opacity: .9;
            pointer-events:none;
        }

        .intro-logo{
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 10px;
        }
        .intro-mark{
            width: 46px;
            height: 46px;
            border-radius: 14px;
            background:
                radial-gradient(14px 14px at 65% 35%, rgba(255,255,255,.18), transparent 60%),
                linear-gradient(180deg, rgba(255,77,109,.95), rgba(124,92,255,.75));
            box-shadow: 0 18px 45px rgba(0,0,0,.55), inset 0 1px 0 rgba(255,255,255,.16);
            border: 1px solid rgba(255,255,255,.14);
            position: relative;
        }
        .intro-mark::after{
            content:"";
            position:absolute;
            inset: 10px 11px 10px 11px;
            border-radius: 10px;
            background: rgba(10,10,16,.35);
            border: 1px solid rgba(255,255,255,.10);
        }
        .intro-sub{
            position: relative;
            margin: 8px 0 18px;
            color: rgba(238,240,255,.72);
            font-weight: 650;
            letter-spacing: .3px;
        }
        .intro-tags{
            position: relative;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            margin: 14px 0 18px;
        }
        .tag{
            padding: 6px 10px;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 750;
            letter-spacing: .3px;
            color: rgba(238,240,255,.80);
            background: rgba(255,255,255,.06);
            border: 1px solid rgba(255,255,255,.10);
            box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
        }

        h1 {
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
            color: rgba(255,255,255,.95);
            margin-bottom: 16px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }
        p { line-height: 1.7; color: var(--muted); }
        
        .key {
            display: inline-block;
            background: rgba(255,255,255,.08);
            padding: 3px 8px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,.10);
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-weight: 700;
            margin: 0 2px;
        }

        @media (max-width: 520px) {
            .hud-top { padding: 10px; }
            .stats-box { min-width: 0; padding: 8px 10px; border-radius: 12px; }
            #intro-content { padding: 24px; }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="stats-box">
                <div class="stat-row money"><span class="stat-icon" style="background:#50fa7b"></span> $<span id="ui-money">0</span></div>
                <div class="stat-row" style="margin-bottom:0;color:rgba(238,240,255,.78)"><span class="stat-icon" style="background:#7c5cff"></span> Depth <span id="ui-depth">0</span></div>
                <div class="stat-row" style="margin-bottom:0;color:rgba(238,240,255,.78)"><span class="stat-icon" style="background:#ffb020"></span> Drills <span id="ui-drills">0</span></div>
            </div>
            <div class="stats-box">
                <div class="stat-row ore-coal"><span class="stat-icon" style="background:#2b2b2b; border:1px solid #555"></span> <span id="ui-coal">0</span></div>
                <div class="stat-row ore-iron"><span class="stat-icon" style="background:#A19D94"></span> <span id="ui-iron">0</span></div>
                <div class="stat-row ore-gold"><span class="stat-icon" style="background:#FFD700"></span> <span id="ui-gold">0</span></div>
                <div class="stat-row ore-diamond"><span class="stat-icon" style="background:#00FFFF"></span> <span id="ui-diamond">0</span></div>
                <div class="stat-row" style="color:#46ffb3"><span class="stat-icon" style="background:#46ffb3"></span> <span id="ui-emerald">0</span></div>
                <div class="stat-row" style="color:#ff4d6d"><span class="stat-icon" style="background:#ff4d6d"></span> <span id="ui-ruby">0</span></div>
                <div class="stat-row" style="color:#55a4ff"><span class="stat-icon" style="background:#55a4ff"></span> <span id="ui-sapphire">0</span></div>
                <div class="stat-row" style="color:#bda6ff"><span class="stat-icon" style="background:#bda6ff"></span> <span id="ui-amethyst">0</span></div>
            </div>
        </div>
        <div id="message-area" onclick="interactAction()">Press E to interact</div>
    </div>

    <!-- Forge / Shop Menu -->
    <div id="forge-menu">
        <h2>OGFORGE</h2>
        <p style="margin-top:8px;margin-bottom:14px;color:rgba(238,240,255,.78)">Smelt ore, upgrade gear, go deeper.</p>
        <button class="btn btn-action" onclick="game.sellAll()"><span>SELL ALL</span><span id="ui-sell-preview">$0</span></button>
        <div style="height:10px"></div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
            <div style="text-align:left;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:10px 12px">
                <div style="font-size:11px;letter-spacing:.6px;text-transform:uppercase;color:rgba(238,240,255,.65);margin-bottom:6px">Wallet</div>
                <div style="font-weight:800;font-size:18px;color:#32d583">$<span id="ui-money-menu">0</span></div>
            </div>
            <div style="text-align:left;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:10px 12px">
                <div style="font-size:11px;letter-spacing:.6px;text-transform:uppercase;color:rgba(238,240,255,.65);margin-bottom:6px">Smelter</div>
                <div style="font-weight:800;font-size:18px;color:rgba(255,255,255,.92)"><span id="ui-smelt-mult">1.00×</span> value</div>
            </div>
        </div>
        <div style="height:10px"></div>
        <div style="text-align:left;background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:10px 12px">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                <div style="font-size:11px;letter-spacing:.6px;text-transform:uppercase;color:rgba(238,240,255,.65)">Inventory</div>
                <div style="font-size:11px;color:rgba(238,240,255,.55)">Prices shown are base</div>
            </div>
            <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;font-size:12px">
                <div style="display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border-radius:12px;background:rgba(0,0,0,.18);border:1px solid rgba(255,255,255,.06)">
                    <span><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:#aab0c4;margin-right:8px;box-shadow:0 0 0 1px rgba(255,255,255,.10)"></span>Coal</span>
                    <span><span id="ui-coal-menu">0</span> · $5</span>
                </div>
                <div style="display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border-radius:12px;background:rgba(0,0,0,.18);border:1px solid rgba(255,255,255,.06)">
                    <span><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:#ffb86c;margin-right:8px;box-shadow:0 0 0 1px rgba(255,255,255,.10)"></span>Iron</span>
                    <span><span id="ui-iron-menu">0</span> · $15</span>
                </div>
                <div style="display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border-radius:12px;background:rgba(0,0,0,.18);border:1px solid rgba(255,255,255,.06)">
                    <span><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:#ffd56a;margin-right:8px;box-shadow:0 0 0 1px rgba(255,255,255,.10)"></span>Gold</span>
                    <span><span id="ui-gold-menu">0</span> · $40</span>
                </div>
                <div style="display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border-radius:12px;background:rgba(0,0,0,.18);border:1px solid rgba(255,255,255,.06)">
                    <span><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:#39e6ff;margin-right:8px;box-shadow:0 0 0 1px rgba(255,255,255,.10)"></span>Diamond</span>
                    <span><span id="ui-diamond-menu">0</span> · $100</span>
                </div>
                <div style="display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border-radius:12px;background:rgba(0,0,0,.18);border:1px solid rgba(255,255,255,.06)">
                    <span><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:#46ffb3;margin-right:8px;box-shadow:0 0 0 1px rgba(255,255,255,.10)"></span>Emerald</span>
                    <span><span id="ui-emerald-menu">0</span> · $180</span>
                </div>
                <div style="display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border-radius:12px;background:rgba(0,0,0,.18);border:1px solid rgba(255,255,255,.06)">
                    <span><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:#ff4d6d;margin-right:8px;box-shadow:0 0 0 1px rgba(255,255,255,.10)"></span>Ruby</span>
                    <span><span id="ui-ruby-menu">0</span> · $260</span>
                </div>
                <div style="display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border-radius:12px;background:rgba(0,0,0,.18);border:1px solid rgba(255,255,255,.06)">
                    <span><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:#55a4ff;margin-right:8px;box-shadow:0 0 0 1px rgba(255,255,255,.10)"></span>Sapphire</span>
                    <span><span id="ui-sapphire-menu">0</span> · $380</span>
                </div>
                <div style="display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border-radius:12px;background:rgba(0,0,0,.18);border:1px solid rgba(255,255,255,.06)">
                    <span><span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:#bda6ff;margin-right:8px;box-shadow:0 0 0 1px rgba(255,255,255,.10)"></span>Amethyst</span>
                    <span><span id="ui-amethyst-menu">0</span> · $600</span>
                </div>
            </div>
        </div>
        <hr style="border-color: rgba(255,255,255,.14); opacity: 0.55; margin: 14px 0;">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
            <div style="font-size: 11px; letter-spacing:.6px; text-transform:uppercase; color: rgba(238,240,255,.65);">Upgrades</div>
            <div style="font-size: 11px; color: rgba(238,240,255,.55);">Tap to buy</div>
        </div>
        <button class="btn" id="btn-upg-pick" onclick="game.upgradePickaxe()">
            <span>Better Pickaxe</span>
            <span id="cost-pick">$100</span>
        </button>
        <button class="btn" id="btn-upg-boots" onclick="game.upgradeBoots()">
            <span>Speed Boots</span>
            <span id="cost-boots">$150</span>
        </button>
        <button class="btn" id="btn-upg-light" onclick="game.upgradeLight()">
            <span>Stronger Lamp</span>
            <span id="cost-light">$200</span>
        </button>
        <button class="btn" id="btn-upg-reach" onclick="game.upgradeReach()">
            <span>Long Reach</span>
            <span id="cost-reach">$250</span>
        </button>
        <button class="btn" id="btn-upg-smelt" onclick="game.upgradeSmelter()">
            <span>Smelter Boost</span>
            <span id="cost-smelt">$400</span>
        </button>
        <button class="btn" id="btn-upg-luck" onclick="game.upgradeLuck()">
            <span>Lucky Charm</span>
            <span id="cost-luck">$500</span>
        </button>
        <button class="btn" id="btn-upg-drill" onclick="game.upgradeDrill()">
            <span>Turbo Drill</span>
            <span id="cost-drill">$650</span>
        </button>
        <button class="btn" id="btn-buy-rig" onclick="game.buyDrillRig()">
            <span>Buy Drill Rig</span>
            <span id="cost-rig">$250</span>
        </button>
        <button class="btn" onclick="game.togglePlaceDrill()">
            <span>Place Drill (Q)</span>
            <span style="opacity:.7">Use on walls</span>
        </button>
        <button class="btn btn-close" onclick="restartMine()">Restart Mine</button>
        <button class="btn btn-close" onclick="game.closeForge()">Close</button>
    </div>

    <!-- Intro -->
    <div id="intro-modal">
        <div id="intro-content">
            <div class="intro-logo">
                <div class="intro-mark"></div>
                <h1 style="margin:0">OGFORGE</h1>
            </div>
            <div class="intro-sub">Forge gear. Go deeper. Get rich.</div>
            <div class="intro-tags">
                <div class="tag">Infinite Mine</div>
                <div class="tag">Loot Caches</div>
                <div class="tag">Upgrades</div>
                <div class="tag">Deep Ores</div>
            </div>
            <p>Use <span class="key">WASD</span> or <span class="key">Arrows</span> to move.</p>
            <p><span class="key">Click</span> or <span class="key">Hold Mouse</span> on walls to mine.</p>
            <p>Return to the <span style="color:#ff5555; font-weight:bold;">Central Forge</span> to sell ores and upgrade gear.</p>
            <div style="position:relative; display:grid; gap:10px; margin-top: 18px;">
                <button id="btn-continue" class="btn btn-action" onclick="startGame({newMine:false})" style="display:none">CONTINUE MINE</button>
                <button class="btn btn-action" onclick="startGame({newMine:true})">NEW MINE</button>
            </div>
            <div id="save-hint" style="position:relative; margin-top:10px; font-size:12px; color:rgba(238,240,255,.55); display:none;">
                Progress saves automatically.
            </div>
        </div>
    </div>

<script>
/**
 * OGforge
 * A single-file canvas game.
 */

// --- Constants & Config ---
const TILE_SIZE = 48;

// Tile IDs
const T_FLOOR = 0;
const T_WALL = 1;
const T_COAL = 2;
const T_IRON = 3;
const T_GOLD = 4;
const T_DIAMOND = 5;
const T_EMERALD = 6;
const T_RUBY = 7;
const T_SAPPHIRE = 8;
const T_AMETHYST = 11;
const T_BEDROCK = 9;
const T_FORGE = 10;
const T_CACHE = 12;

// Colors
const COLORS = {
    [T_FLOOR]: '#151520',
    [T_WALL]: '#232336',
    [T_COAL]: '#aab0c4',
    [T_IRON]: '#d1b19c',
    [T_GOLD]: '#ffd56a',
    [T_DIAMOND]: '#39e6ff',
    [T_EMERALD]: '#46ffb3',
    [T_RUBY]: '#ff4d6d',
    [T_SAPPHIRE]: '#55a4ff',
    [T_AMETHYST]: '#bda6ff',
    [T_BEDROCK]: '#0a0a10',
    [T_FORGE]: '#ff4d6d',
    [T_CACHE]: '#ffd56a'
};

// Art palette (used for gradients/glows)
const ART = {
    bg0: '#07070a',
    bg1: '#0c0c12',
    floor0: '#12121b',
    floor1: '#1a1a27',
    wall0: '#1b1b2a',
    wall1: '#2a2a40',
    bedrock0: '#06060b',
    bedrock1: '#0f0f18',
    forgeHot: '#ff4d6d',
    forgeWarm: '#ffb020',
    uiText: '#eef0ff'
};

const SAVE_KEY = 'ogforge-save-v1';

function clamp01(v) {
    return Math.max(0, Math.min(1, v));
}

function hash2(x, y) {
    let h = (x * 374761393 + y * 668265263) >>> 0;
    h = Math.imul(h ^ (h >>> 13), 1274126177) >>> 0;
    return (h ^ (h >>> 16)) >>> 0;
}

function seeded01(seed) {
    const n = (Math.imul(seed >>> 0, 1664525) + 1013904223) >>> 0;
    return n / 4294967296;
}

function roundRectPath(ctx, x, y, w, h, r) {
    const radius = Math.max(0, Math.min(r, w / 2, h / 2));
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.arcTo(x + w, y, x + w, y + h, radius);
    ctx.arcTo(x + w, y + h, x, y + h, radius);
    ctx.arcTo(x, y + h, x, y, radius);
    ctx.arcTo(x, y, x + w, y, radius);
    ctx.closePath();
}

const SaveManager = {
    hasSave() {
        try {
            const raw = localStorage.getItem(SAVE_KEY);
            if (!raw) return false;
            const parsed = JSON.parse(raw);
            return !!parsed && parsed.v === 1;
        } catch {
            return false;
        }
    },
    load() {
        try {
            const raw = localStorage.getItem(SAVE_KEY);
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            if (!parsed || parsed.v !== 1) return null;
            return parsed;
        } catch {
            return null;
        }
    },
    save(state) {
        try {
            localStorage.setItem(SAVE_KEY, JSON.stringify(state));
            return true;
        } catch {
            return false;
        }
    },
    clear() {
        try {
            localStorage.removeItem(SAVE_KEY);
        } catch {}
    }
};

class TileArt {
    constructor(tileSize) {
        this.tileSize = tileSize;
        this.variants = 12;
        this.cache = new Map();
        this._buildAll();
    }

    get(type, x, y) {
        const v = hash2(x, y) % this.variants;
        return this.cache.get(`${type}:${v}`) || this.cache.get(`${type}:0`);
    }

    _canvas() {
        const c = document.createElement('canvas');
        c.width = this.tileSize;
        c.height = this.tileSize;
        return c;
    }

    _speckle(ctx, seed, color, count, sizeMin, sizeMax, alphaMin, alphaMax) {
        for (let i = 0; i < count; i++) {
            const s = (seed + i * 9973) >>> 0;
            const rx = seeded01(s) * this.tileSize;
            const ry = seeded01(s ^ 0x9e3779b9) * this.tileSize;
            const r = sizeMin + seeded01(s ^ 0x85ebca6b) * (sizeMax - sizeMin);
            const a = alphaMin + seeded01(s ^ 0xc2b2ae35) * (alphaMax - alphaMin);
            ctx.globalAlpha = a;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(rx, ry, r, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }

    _stoneBase(ctx, seed, c0, c1) {
        const g = ctx.createLinearGradient(0, 0, this.tileSize, this.tileSize);
        g.addColorStop(0, c0);
        g.addColorStop(1, c1);
        ctx.fillStyle = g;
        roundRectPath(ctx, 0.5, 0.5, this.tileSize - 1, this.tileSize - 1, 10);
        ctx.fill();

        // Soft inner shadow / depth
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.lineWidth = 1;
        roundRectPath(ctx, 1.5, 1.5, this.tileSize - 3, this.tileSize - 3, 9);
        ctx.stroke();

        // Texture
        this._speckle(ctx, seed ^ 0x1234, 'rgba(255,255,255,0.08)', 28, 0.6, 1.6, 0.10, 0.35);
        this._speckle(ctx, seed ^ 0x5678, 'rgba(0,0,0,0.25)', 22, 0.8, 2.2, 0.08, 0.22);

        // Edge vignette
        const vg = ctx.createRadialGradient(
            this.tileSize / 2,
            this.tileSize / 2,
            this.tileSize * 0.12,
            this.tileSize / 2,
            this.tileSize / 2,
            this.tileSize * 0.75
        );
        vg.addColorStop(0, 'rgba(0,0,0,0)');
        vg.addColorStop(1, 'rgba(0,0,0,0.22)');
        ctx.fillStyle = vg;
        roundRectPath(ctx, 0.5, 0.5, this.tileSize - 1, this.tileSize - 1, 10);
        ctx.fill();
    }

    _oreOverlay(ctx, seed, color, kind) {
        const cx = this.tileSize / 2;
        const cy = this.tileSize / 2;

        // Subtle glow
        ctx.globalAlpha = 0.9;
        ctx.shadowColor = color;
        ctx.shadowBlur = 18;
        ctx.fillStyle = color;

        if (kind === 'diamond') {
            ctx.beginPath();
            ctx.moveTo(cx, cy - 10);
            ctx.lineTo(cx + 10, cy);
            ctx.lineTo(cx, cy + 10);
            ctx.lineTo(cx - 10, cy);
            ctx.closePath();
            ctx.fill();
        } else {
            const n = 3 + Math.floor(seeded01(seed ^ 0xaaa) * 2);
            for (let i = 0; i < n; i++) {
                const s = (seed + i * 7919) >>> 0;
                const ox = (seeded01(s) - 0.5) * 16;
                const oy = (seeded01(s ^ 0x9e37) - 0.5) * 16;
                const r = 4 + seeded01(s ^ 0x85eb) * 5;
                ctx.beginPath();
                ctx.arc(cx + ox, cy + oy, r, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;

        // Specular highlight
        ctx.globalAlpha = 0.25;
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(cx - 6, cy - 7, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }

    _build(type, v, drawFn) {
        const c = this._canvas();
        const ctx = c.getContext('2d');
        drawFn(ctx, (type * 1000 + v * 1337) >>> 0);
        this.cache.set(`${type}:${v}`, c);
    }

    _buildAll() {
        for (let v = 0; v < this.variants; v++) {
            this._build(T_FLOOR, v, (ctx, seed) => {
                this._stoneBase(ctx, seed, ART.floor0, ART.floor1);
            });

            this._build(T_WALL, v, (ctx, seed) => {
                this._stoneBase(ctx, seed, ART.wall0, ART.wall1);
                // Bevel highlights
                const gTop = ctx.createLinearGradient(0, 0, 0, 10);
                gTop.addColorStop(0, 'rgba(255,255,255,0.10)');
                gTop.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = gTop;
                roundRectPath(ctx, 1, 1, this.tileSize - 2, 12, 9);
                ctx.fill();
            });

            this._build(T_BEDROCK, v, (ctx, seed) => {
                this._stoneBase(ctx, seed, ART.bedrock0, ART.bedrock1);
                this._speckle(ctx, seed ^ 0xdead, 'rgba(255,255,255,0.05)', 18, 0.8, 2.6, 0.06, 0.18);
                // Darken edges more
                ctx.globalAlpha = 0.35;
                ctx.fillStyle = '#000';
                roundRectPath(ctx, 0.5, 0.5, this.tileSize - 1, this.tileSize - 1, 10);
                ctx.fill();
                ctx.globalAlpha = 1;
            });

            const oreBuild = (type, color, kind) => {
                this._build(type, v, (ctx, seed) => {
                    this._stoneBase(ctx, seed, ART.wall0, ART.wall1);
                    this._oreOverlay(ctx, seed ^ 0x1337, color, kind);
                });
            };

            oreBuild(T_COAL, 'rgba(210,215,235,0.72)', 'coal');
            oreBuild(T_IRON, 'rgba(255,184,108,0.82)', 'iron');
            oreBuild(T_GOLD, 'rgba(255,213,106,0.90)', 'gold');
            oreBuild(T_DIAMOND, 'rgba(57,230,255,0.95)', 'diamond');
            oreBuild(T_EMERALD, 'rgba(70,255,179,0.95)', 'emerald');
            oreBuild(T_RUBY, 'rgba(255,77,109,0.95)', 'ruby');
            oreBuild(T_SAPPHIRE, 'rgba(85,164,255,0.95)', 'sapphire');
            oreBuild(T_AMETHYST, 'rgba(189,166,255,0.95)', 'amethyst');

            this._build(T_CACHE, v, (ctx, seed) => {
                this._stoneBase(ctx, seed, ART.floor0, ART.floor1);

                // Chest base
                ctx.save();
                ctx.shadowColor = 'rgba(255,213,106,0.65)';
                ctx.shadowBlur = 14;
                const x = 10;
                const y = 18;
                const w = this.tileSize - 20;
                const h = this.tileSize - 26;
                const g = ctx.createLinearGradient(0, y, 0, y + h);
                g.addColorStop(0, 'rgba(255,213,106,0.95)');
                g.addColorStop(1, 'rgba(255,176,32,0.82)');
                ctx.fillStyle = g;
                roundRectPath(ctx, x, y, w, h, 10);
                ctx.fill();

                // Lid line
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 0.35;
                ctx.fillStyle = '#000';
                roundRectPath(ctx, x + 1, y + 10, w - 2, 2, 2);
                ctx.fill();
                ctx.globalAlpha = 1;

                // Lock
                ctx.fillStyle = 'rgba(20,20,28,0.95)';
                roundRectPath(ctx, this.tileSize / 2 - 4, y + 12, 8, 10, 3);
                ctx.fill();
                ctx.fillStyle = 'rgba(255,255,255,0.75)';
                ctx.beginPath();
                ctx.arc(this.tileSize / 2, y + 16, 1.4, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }
    }
}

// Mining Health (Hits required)
const TILE_HP = {
    [T_WALL]: 60,
    [T_COAL]: 80,
    [T_IRON]: 120,
    [T_GOLD]: 200,
    [T_DIAMOND]: 300,
    [T_EMERALD]: 420,
    [T_RUBY]: 550,
    [T_SAPPHIRE]: 700,
    [T_AMETHYST]: 900
};

// Ore Values
const ORE_VALUE = {
    coal: 5,
    iron: 15,
    gold: 40,
    diamond: 100,
    emerald: 180,
    ruby: 260,
    sapphire: 380,
    amethyst: 600
};

// --- Game Engine Classes ---

class Input {
    constructor() {
        this.keys = {};
        this.mouse = { x: 0, y: 0, down: false };
        this.worldMouse = { x: 0, y: 0 };

        window.addEventListener('keydown', e => this.keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
        
        window.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            this.mouse.x = e.clientX - rect.left;
            this.mouse.y = e.clientY - rect.top;
        });

        window.addEventListener('mousedown', () => this.mouse.down = true);
        window.addEventListener('mouseup', () => this.mouse.down = false);
        
        // Touch controls for mining
        window.addEventListener('touchstart', (e) => {
             const rect = canvas.getBoundingClientRect();
             this.mouse.x = e.touches[0].clientX - rect.left;
             this.mouse.y = e.touches[0].clientY - rect.top;
             this.mouse.down = true;
             e.preventDefault();
        }, {passive: false});

        window.addEventListener('touchmove', (e) => {
            const rect = canvas.getBoundingClientRect();
            this.mouse.x = e.touches[0].clientX - rect.left;
            this.mouse.y = e.touches[0].clientY - rect.top;
            e.preventDefault();
        }, {passive: false});
        
        window.addEventListener('touchend', () => this.mouse.down = false);
    }
}

class Camera {
    constructor(width, height) {
        this.x = 0;
        this.y = 0;
        this.width = width;
        this.height = height;
    }
    
    follow(target, mapWidthPx, mapHeightPx) {
        // Center on target
        this.x = target.x - this.width / 2;
        this.y = target.y - this.height / 2;
        
        // Clamp to bounds (only when provided)
        if (Number.isFinite(mapWidthPx) && Number.isFinite(mapHeightPx)) {
            this.x = Math.max(0, Math.min(this.x, mapWidthPx - this.width));
            this.y = Math.max(0, Math.min(this.y, mapHeightPx - this.height));
        }
    }
}

class Particle {
    constructor(x, y, color, speed, life) {
        this.x = x;
        this.y = y;
        this.color = color;
        const angle = Math.random() * Math.PI * 2;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = life;
        this.maxLife = life;
        this.size = Math.random() * 3 + 1;
        this.gravity = 0.1;
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += this.gravity; // Gravity
        this.vx *= 0.95; // Friction
        this.life--;
    }
    
    draw(ctx, camX, camY) {
        const a = this.life / this.maxLife;
        ctx.globalAlpha = a;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x - camX, this.y - camY, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

class Shockwave {
    constructor(x, y, color, maxRadius, life) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.maxRadius = maxRadius;
        this.life = life;
        this.maxLife = life;
    }

    update() {
        this.life--;
    }

    draw(ctx, camX, camY) {
        const t = 1 - this.life / this.maxLife;
        const r = 4 + this.maxRadius * t;
        const a = Math.max(0, 1 - t);
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = 0.55 * a;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x - camX, this.y - camY, r, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 0.25 * a;
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.arc(this.x - camX, this.y - camY, r * 0.7, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
    }
}

class DrillRig {
    constructor(tx, ty) {
        this.tx = tx;
        this.ty = ty;
        this.x = tx * TILE_SIZE + TILE_SIZE / 2;
        this.y = ty * TILE_SIZE + TILE_SIZE / 2;
        this.cooldown = 0;
        this.target = null;
        this.life = 1;
    }

    _findTarget(map) {
        const r = 3;
        let best = null;
        for (let dy = -r; dy <= r; dy++) {
            for (let dx = -r; dx <= r; dx++) {
                const tx = this.tx + dx;
                const ty = this.ty + dy;
                const t = map.getTile(tx, ty);
                if (t === T_FLOOR || t === T_BEDROCK || t === T_FORGE || t === T_CACHE) continue;
                const hp = map.getHp(tx, ty);
                if (hp <= 0) continue;
                const d2 = dx * dx + dy * dy;
                if (!best || d2 < best.d2) best = { tx, ty, d2, t };
            }
        }
        this.target = best;
    }

    update(game) {
        if (this.cooldown > 0) this.cooldown--;
        if (!this.target || game.map.getTile(this.target.tx, this.target.ty) === T_FLOOR) this._findTarget(game.map);
        if (!this.target) return;
        if (this.cooldown > 0) return;

        const { tx, ty } = this.target;
        const tile = game.map.getTile(tx, ty);
        if (tile === T_FLOOR || tile === T_BEDROCK || tile === T_FORGE || tile === T_CACHE) {
            this.target = null;
            return;
        }

        const power = 2.2;
        const interval = 12;
        this.cooldown = interval;

        const hp = game.map.getHp(tx, ty) - power;
        game.map.setHp(tx, ty, hp);

        const wx = tx * TILE_SIZE + TILE_SIZE / 2;
        const wy = ty * TILE_SIZE + TILE_SIZE / 2;
        const c = COLORS[tile] || '#fff';
        game.particles.push(new Particle(wx, wy, c, 2.2, 18));
        if (Math.random() < 0.35) game.effects.push(new Shockwave(wx, wy, c, 14, 10));

        if (hp <= 0) game.breakTile(tx, ty, tile);
    }

    draw(ctx, camX, camY, time) {
        const x = this.x - camX;
        const y = this.y - camY;
        const t = time || 0;
        const pulse = 0.5 + 0.5 * Math.sin(t * 0.14 + (this.tx + this.ty) * 0.3);

        ctx.save();
        ctx.translate(x, y);
        ctx.shadowColor = 'rgba(255,176,32,0.45)';
        ctx.shadowBlur = 12;
        ctx.fillStyle = 'rgba(20,20,28,0.92)';
        roundRectPath(ctx, -14, -10, 28, 22, 10);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.strokeStyle = 'rgba(255,255,255,0.12)';
        ctx.lineWidth = 1;
        roundRectPath(ctx, -14, -10, 28, 22, 10);
        ctx.stroke();

        // Bit
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = 0.65 + 0.25 * pulse;
        ctx.fillStyle = 'rgba(255,176,32,0.95)';
        ctx.beginPath();
        ctx.moveTo(10, -4);
        ctx.lineTo(18, 0);
        ctx.lineTo(10, 4);
        ctx.closePath();
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = 'source-over';

        // Base feet
        ctx.fillStyle = 'rgba(0,0,0,0.35)';
        roundRectPath(ctx, -16, 10, 32, 6, 4);
        ctx.fill();
        ctx.restore();
    }
}

class AudioManager {
    constructor() {
        this.ctx = null;
        this.master = null;
        this._humOsc = null;
        this._humGain = null;
    }

    ensure() {
        if (!this.ctx) {
            const Ctx = window.AudioContext || window.webkitAudioContext;
            if (!Ctx) return;
            this.ctx = new Ctx();
            this.master = this.ctx.createGain();
            this.master.gain.value = 0.45;
            this.master.connect(this.ctx.destination);
        }
        if (this.ctx.state === 'suspended') this.ctx.resume();
    }

    _noise(durationSec, filterHz, gainValue) {
        this.ensure();
        if (!this.ctx) return;
        const sr = this.ctx.sampleRate;
        const frames = Math.max(1, Math.floor(sr * durationSec));
        const buffer = this.ctx.createBuffer(1, frames, sr);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < frames; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / frames);

        const src = this.ctx.createBufferSource();
        src.buffer = buffer;

        const filter = this.ctx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = filterHz;

        const gain = this.ctx.createGain();
        gain.gain.value = gainValue;

        src.connect(filter);
        filter.connect(gain);
        gain.connect(this.master);

        const now = this.ctx.currentTime;
        gain.gain.setValueAtTime(gainValue, now);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + durationSec);
        src.start();
        src.stop(now + durationSec);
    }

    _tone(freq, durationSec, gainValue, type = 'sine') {
        this.ensure();
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        gain.gain.value = gainValue;
        osc.connect(gain);
        gain.connect(this.master);
        const now = this.ctx.currentTime;
        gain.gain.setValueAtTime(gainValue, now);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + durationSec);
        osc.start();
        osc.stop(now + durationSec);
    }

    playMineHit(tileType) {
        const bright = (tileType === T_DIAMOND || tileType === T_SAPPHIRE || tileType === T_AMETHYST) ? 1600 : 1100;
        this._noise(0.045, bright, 0.18);
        this._tone(140 + Math.random() * 40, 0.04, 0.05, 'square');
    }

    playMineBreak(tileType) {
        this._noise(0.085, 900, 0.24);
        if (tileType !== T_WALL && tileType !== T_COAL && tileType !== T_IRON) {
            this._tone(520 + Math.random() * 160, 0.08, 0.06, 'triangle');
        }
    }

    playCacheOpen() {
        this._tone(660, 0.09, 0.10, 'triangle');
        this._tone(990, 0.10, 0.07, 'sine');
        this._noise(0.06, 1400, 0.10);
    }

    startForgeHum() {
        this.ensure();
        if (!this.ctx) return;
        if (this._humOsc) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.value = 58;
        gain.gain.value = 0.00;
        osc.connect(gain);
        gain.connect(this.master);
        osc.start();
        this._humOsc = osc;
        this._humGain = gain;
    }

    setForgeHum(active) {
        if (!this.ctx) return;
        if (!this._humOsc) this.startForgeHum();
        if (!this._humGain) return;
        const now = this.ctx.currentTime;
        const target = active ? 0.06 : 0.0001;
        this._humGain.gain.cancelScheduledValues(now);
        this._humGain.gain.setValueAtTime(this._humGain.gain.value, now);
        this._humGain.gain.exponentialRampToValueAtTime(target, now + 0.12);
    }
}

class Floater {
    constructor(x, y, text, color) {
        this.x = x;
        this.y = y;
        this.text = text;
        this.color = color;
        this.life = 60;
        this.vy = -1;
    }
    
    update() {
        this.y += this.vy;
        this.life--;
    }
    
    draw(ctx, camX, camY) {
        ctx.globalAlpha = Math.max(0, this.life / 60);
        ctx.fillStyle = this.color;
        ctx.font = "700 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
        ctx.strokeStyle = "rgba(0,0,0,0.75)";
        ctx.lineWidth = 4;
        ctx.strokeText(this.text, this.x - camX, this.y - camY);
        ctx.fillText(this.text, this.x - camX, this.y - camY);
        ctx.globalAlpha = 1;
    }
}

class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 10;
        this.speed = 3;
        this.vx = 0;
        this.vy = 0;
        this.facing = 1; // -1 left, +1 right
        this.minePulse = 0; // 0..1
        this.drillRigs = 0;
        
        // Stats
        this.money = 0;
        this.inventory = { coal: 0, iron: 0, gold: 0, diamond: 0, emerald: 0, ruby: 0, sapphire: 0, amethyst: 0 };
        
        // Upgrades
        this.miningPower = 2; // Damage per tick
        this.lightRadius = 150;
        this.maxSpeed = 3;
        this.miningRange = 80;
        this.miningInterval = 5; // Damage applied every N ticks while mining
        this.sellMultiplier = 1.0;
        this.luck = 0.0; // Chance for bonus drops
        
        // Upgrade Levels (for costs)
        this.levels = { pick: 1, boots: 1, light: 1, reach: 1, smelt: 1, luck: 1, drill: 1 };
    }
    
    update(input, map) {
        // Movement Input
        let dx = 0;
        let dy = 0;
        
        if (input.keys['w'] || input.keys['arrowup']) dy = -1;
        if (input.keys['s'] || input.keys['arrowdown']) dy = 1;
        if (input.keys['a'] || input.keys['arrowleft']) dx = -1;
        if (input.keys['d'] || input.keys['arrowright']) dx = 1;
        
        // Normalize vector
        if (dx !== 0 || dy !== 0) {
            const len = Math.sqrt(dx*dx + dy*dy);
            dx /= len;
            dy /= len;
        }
        
        this.vx = dx * this.maxSpeed;
        this.vy = dy * this.maxSpeed;
        if (dx !== 0) this.facing = dx > 0 ? 1 : -1;
        this.minePulse *= 0.86;
        
        // Collision Resolution (X axis)
        let nextX = this.x + this.vx;
        if (!map.isSolidAt(nextX, this.y, this.radius)) {
            this.x = nextX;
        }
        
        // Collision Resolution (Y axis)
        let nextY = this.y + this.vy;
        if (!map.isSolidAt(this.x, nextY, this.radius)) {
            this.y = nextY;
        }
    }

    pulseMine() {
        this.minePulse = Math.min(1, this.minePulse + 0.85);
    }
    
    draw(ctx, camX, camY, time) {
        const px = this.x - camX;
        const py = this.y - camY;
        const t = time || 0;
        const speed = Math.hypot(this.vx, this.vy) / Math.max(0.001, this.maxSpeed);
        const mine = this.minePulse;
        const bob = Math.sin(t * 0.18) * (0.55 + 0.45 * speed);

        // Shadow
        ctx.fillStyle = `rgba(0,0,0,${0.26 + 0.10 * speed})`;
        ctx.beginPath();
        ctx.ellipse(px, py + 12, 9.5 + 2 * speed, 3.2, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.save();
        ctx.translate(px, py + bob);
        ctx.scale(this.facing, 1);

        // Dot body
        const g = ctx.createRadialGradient(-3, -5, 2, 0, 0, 18);
        g.addColorStop(0, '#d9d1ff');
        g.addColorStop(0.55, '#7c5cff');
        g.addColorStop(1, '#4f2bff');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = 'rgba(0,0,0,0.55)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.stroke();

        // Helmet lamp (simple)
        ctx.shadowColor = 'rgba(255,224,138,0.85)';
        ctx.shadowBlur = 16;
        ctx.fillStyle = '#ffe08a';
        ctx.beginPath();
        ctx.arc(6.8, -5.5, 3.7, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        ctx.beginPath();
        ctx.arc(6.1, -6.2, 1.2, 0, Math.PI * 2);
        ctx.fill();

        // Hand + pickaxe (kept simple)
        const handX = 10.0;
        const handY = 6.0;
        ctx.fillStyle = 'rgba(22,22,34,0.9)';
        ctx.beginPath();
        ctx.arc(handX, handY, 2.8, 0, Math.PI * 2);
        ctx.fill();

        ctx.save();
        const swing = (-0.65 + 1.15 * mine) + Math.sin(t * 0.05) * (0.03 + 0.07 * speed);
        ctx.translate(handX, handY);
        ctx.rotate(swing);

        // Handle
        const handleG = ctx.createLinearGradient(0, 0, 0, 24);
        handleG.addColorStop(0, 'rgba(255,213,106,0.80)');
        handleG.addColorStop(1, 'rgba(120,78,18,0.98)');
        ctx.strokeStyle = handleG;
        ctx.lineWidth = 4.2;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(0, -1.5);
        ctx.lineTo(0, 22);
        ctx.stroke();

        // Head
        ctx.shadowColor = 'rgba(57,230,255,0.22)';
        ctx.shadowBlur = 12;
        ctx.fillStyle = 'rgba(210,220,235,0.95)';
        roundRectPath(ctx, -11, -10, 22, 7.8, 4);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 0.65;
        ctx.strokeStyle = 'rgba(0,0,0,0.45)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(-11, -6);
        ctx.lineTo(11, -6);
        ctx.stroke();
        ctx.globalAlpha = 1;

        // Tiny spark on mine
        if (mine > 0.4) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = 0.25 + 0.5 * mine;
            ctx.strokeStyle = 'rgba(255,255,255,0.85)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(12, -8);
            ctx.lineTo(18, -12);
            ctx.stroke();
            ctx.restore();
        }

        ctx.restore();

        ctx.restore();
    }
}

class InfiniteMap {
    constructor() {
        this.modifiedTiles = new Map(); // key -> tileId
        this.modifiedHp = new Map(); // key -> hp
        this.forgeTile = { x: 0, y: -2 };
        this.spawnTile = { x: 0, y: 0 };
    }

    key(x, y) {
        return `${x},${y}`;
    }

    inSpawnRoom(tx, ty) {
        const dx = tx - this.spawnTile.x;
        const dy = ty - this.spawnTile.y;
        return Math.sqrt(dx * dx + dy * dy) <= 4.2;
    }

    structureTileAt(tx, ty) {
        const spacing = 34;
        const cellX = Math.floor(tx / spacing);
        const cellY = Math.floor(ty / spacing);
        if (Math.abs(cellX) <= 1 && Math.abs(cellY) <= 1) return null;

        const seed = hash2(cellX, cellY);
        const chance = seeded01(seed ^ 0x5a1f0b);
        if (chance < 0.88) return null;

        const cx = cellX * spacing + Math.floor(spacing / 2) + Math.floor((seeded01(seed ^ 0xa2c3) - 0.5) * (spacing * 0.6));
        const cy = cellY * spacing + Math.floor(spacing / 2) + Math.floor((seeded01(seed ^ 0xf00d) - 0.5) * (spacing * 0.6));

        const w = 9 + Math.floor(seeded01(seed ^ 0x9e37) * 8); // 9..16
        const h = 7 + Math.floor(seeded01(seed ^ 0x7f4a) * 7); // 7..13
        const halfW = Math.floor(w / 2);
        const halfH = Math.floor(h / 2);

        const rx = tx - cx;
        const ry = ty - cy;
        if (Math.abs(rx) > halfW || Math.abs(ry) > halfH) return null;

        const onEdge = Math.abs(rx) === halfW || Math.abs(ry) === halfH;
        if (onEdge) return T_WALL;

        const d = Math.sqrt(tx * tx + ty * ty);
        if (d > 28 && tx === cx && ty === cy && seeded01(seed ^ 0x13371337) > 0.25) return T_CACHE;
        return T_FLOOR;
    }

    baseTileAt(tx, ty) {
        if (tx === this.forgeTile.x && ty === this.forgeTile.y) return T_FORGE;
        if (this.inSpawnRoom(tx, ty)) return T_FLOOR;

        const structure = this.structureTileAt(tx, ty);
        if (structure !== null) return structure;

        // Occasional natural caves
        const caveRand = seeded01(hash2(tx + 18013, ty - 9127));
        const d = Math.sqrt(tx * tx + ty * ty);
        const depth = clamp01((d - 8) / 140); // deeper => rarer ores
        const caveChance = 0.05 + 0.03 * depth;
        if (caveRand < caveChance) return T_FLOOR;

        // Ore distribution (deterministic by depth)
        const r = seeded01(hash2(tx, ty));
        const lerp = (a, b, t) => a + (b - a) * t;

        const pAmethyst = lerp(0.00025, 0.00220, depth);
        const pSapphire = lerp(0.00055, 0.00310, depth);
        const pRuby = lerp(0.00100, 0.00460, depth);
        const pEmerald = lerp(0.00220, 0.00760, depth);
        const pDiamond = lerp(0.00950, 0.0200, depth);
        const pGold = lerp(0.0320, 0.0600, depth);
        const pIron = lerp(0.1050, 0.1350, depth);
        const pCoal = lerp(0.2400, 0.1200, depth);

        let t = r;
        if ((t -= pAmethyst) < 0) return T_AMETHYST;
        if ((t -= pSapphire) < 0) return T_SAPPHIRE;
        if ((t -= pRuby) < 0) return T_RUBY;
        if ((t -= pEmerald) < 0) return T_EMERALD;
        if ((t -= pDiamond) < 0) return T_DIAMOND;
        if ((t -= pGold) < 0) return T_GOLD;
        if ((t -= pIron) < 0) return T_IRON;
        if ((t -= pCoal) < 0) return T_COAL;
        return T_WALL;
    }

    getTile(tx, ty) {
        const k = this.key(tx, ty);
        if (this.modifiedTiles.has(k)) return this.modifiedTiles.get(k);
        return this.baseTileAt(tx, ty);
    }

    setTile(tx, ty, tile) {
        const k = this.key(tx, ty);
        this.modifiedTiles.set(k, tile);
        this.modifiedHp.set(k, TILE_HP[tile] || 0);
    }

    getHp(tx, ty) {
        const k = this.key(tx, ty);
        if (this.modifiedHp.has(k)) return this.modifiedHp.get(k);
        const t = this.getTile(tx, ty);
        return TILE_HP[t] || 0;
    }

    setHp(tx, ty, hp) {
        const k = this.key(tx, ty);
        this.modifiedHp.set(k, hp);
    }

    serializeNear(centerTx, centerTy, maxEntries) {
        const tiles = [];
        const hp = [];
        for (const [k, v] of this.modifiedTiles.entries()) tiles.push([k, v]);
        for (const [k, v] of this.modifiedHp.entries()) hp.push([k, v]);

        const prune = (arr) => {
            if (arr.length <= maxEntries) return arr;
            const scored = arr.map(([k, v]) => {
                const [x, y] = k.split(',').map(n => parseInt(n, 10));
                const d2 = (x - centerTx) * (x - centerTx) + (y - centerTy) * (y - centerTy);
                return { k, v, d2 };
            });
            scored.sort((a, b) => a.d2 - b.d2);
            return scored.slice(0, maxEntries).map(s => [s.k, s.v]);
        };

        return { tiles: prune(tiles), hp: prune(hp) };
    }

    isSolidAt(px, py, radius) {
        const checkTile = (x, y) => {
            const tx = Math.floor(x / TILE_SIZE);
            const ty = Math.floor(y / TILE_SIZE);
            const t = this.getTile(tx, ty);
            return t !== T_FLOOR && t !== T_FORGE && t !== T_CACHE;
        };

        return checkTile(px - radius + 2, py) ||
               checkTile(px + radius - 2, py) ||
               checkTile(px, py - radius + 2) ||
               checkTile(px, py + radius - 2);
    }
}

// --- Main Game Logic ---

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let gameRunning = false;
let game;

class Game {
    constructor() {
        this.resize();
        this.input = new Input();
        this.map = new InfiniteMap();
        this.tileArt = new TileArt(TILE_SIZE);
        this.time = 0;
        this.hoveredTile = null;
        this._grainPattern = this._makeGrainPattern();
        this.effects = [];
        this.shakeMag = 0;
        this.shakeX = 0;
        this.shakeY = 0;
        this.renderCamX = 0;
        this.renderCamY = 0;

        this.audio = new AudioManager();

        this.uiDepth = document.getElementById('ui-depth');
        
        // Spawn player in middle
        const startX = (this.map.spawnTile.x) * TILE_SIZE + TILE_SIZE / 2;
        const startY = (this.map.spawnTile.y) * TILE_SIZE + TILE_SIZE / 2;
        
        this.player = new Player(startX, startY);
        this.camera = new Camera(this.viewportWidth, this.viewportHeight);
        this.particles = [];
        this.floaters = [];
        this.drills = [];
        this.placeDrillMode = false;
        this._mouseWasDown = false;
        
        this.miningTick = 0;
        this.isForgeOpen = false;
        this._autosaveTick = 0;
        
        // Listen for interaction key
        window.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'e') this.interact();
            if (e.key.toLowerCase() === 'q') this.togglePlaceDrill();
        });
    }

    _makeGrainPattern() {
        const g = document.createElement('canvas');
        g.width = 128;
        g.height = 128;
        const gctx = g.getContext('2d');
        const img = gctx.createImageData(g.width, g.height);
        for (let i = 0; i < img.data.length; i += 4) {
            const v = Math.floor(Math.random() * 255);
            img.data[i] = v;
            img.data[i + 1] = v;
            img.data[i + 2] = v;
            img.data[i + 3] = 255;
        }
        gctx.putImageData(img, 0, 0);
        return ctx.createPattern(g, 'repeat');
    }
    
    resize() {
        const cssW = window.innerWidth;
        const cssH = window.innerHeight;
        const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));

        this.viewportWidth = cssW;
        this.viewportHeight = cssH;

        canvas.style.width = `${cssW}px`;
        canvas.style.height = `${cssH}px`;
        canvas.width = Math.floor(cssW * dpr);
        canvas.height = Math.floor(cssH * dpr);

        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.imageSmoothingEnabled = true;

        if (this.camera) {
            this.camera.width = cssW;
            this.camera.height = cssH;
        }
    }
    
    interact() {
        const cache = this.findNearbyCache();
        if (cache) {
            this.openCache(cache.tx, cache.ty);
            return;
        }

        // Check distance to forge
        const forgeX = (this.map.forgeTile.x) * TILE_SIZE + TILE_SIZE/2;
        const forgeY = (this.map.forgeTile.y) * TILE_SIZE + TILE_SIZE/2;
        const dist = Math.sqrt((this.player.x - forgeX)**2 + (this.player.y - forgeY)**2);
        
        if (dist < 100) {
            this.openForge();
        }
    }
    
    openForge() {
        this.isForgeOpen = true;
        document.getElementById('forge-menu').style.display = 'block';
        this.updateUi();
    }
    
    closeForge() {
        this.isForgeOpen = false;
        document.getElementById('forge-menu').style.display = 'none';
    }

    buyDrillRig() {
        const cost = this.getDrillRigCost();
        if (this.player.money < cost) return;
        this.player.money -= cost;
        this.player.drillRigs++;
        this.updateUi();
        this.saveProgress();
    }

    getDrillRigCost() {
        return Math.floor(250 * (1 + this.player.drillRigs * 0.5));
    }

    togglePlaceDrill() {
        if (!gameRunning) return;
        if (this.isForgeOpen) {
            this.closeForge();
        }
        if (this.player.drillRigs <= 0) {
            this.placeDrillMode = false;
            return;
        }
        this.placeDrillMode = !this.placeDrillMode;
    }
    
    sellAll() {
        let total = 0;
        total += this.player.inventory.coal * ORE_VALUE.coal;
        total += this.player.inventory.iron * ORE_VALUE.iron;
        total += this.player.inventory.gold * ORE_VALUE.gold;
        total += this.player.inventory.diamond * ORE_VALUE.diamond;
        total += this.player.inventory.emerald * ORE_VALUE.emerald;
        total += this.player.inventory.ruby * ORE_VALUE.ruby;
        total += this.player.inventory.sapphire * ORE_VALUE.sapphire;
        total += this.player.inventory.amethyst * ORE_VALUE.amethyst;
        total = Math.floor(total * this.player.sellMultiplier);
        
        if (total > 0) {
            this.player.money += total;
            this.player.inventory.coal = 0;
            this.player.inventory.iron = 0;
            this.player.inventory.gold = 0;
            this.player.inventory.diamond = 0;
            this.player.inventory.emerald = 0;
            this.player.inventory.ruby = 0;
            this.player.inventory.sapphire = 0;
            this.player.inventory.amethyst = 0;
            this.spawnFloater(this.player.x, this.player.y - 20, `+$${total}`, '#50fa7b');
            this.updateUi();
        }
    }
    
    upgradePickaxe() {
        const cost = this.player.levels.pick * 100;
        if (this.player.money >= cost) {
            this.player.money -= cost;
            this.player.miningPower += 2;
            this.player.levels.pick++;
            this.updateUi();
        }
    }

    upgradeBoots() {
        const cost = this.player.levels.boots * 150;
        if (this.player.money >= cost) {
            this.player.money -= cost;
            this.player.maxSpeed += 0.5;
            this.player.levels.boots++;
            this.updateUi();
        }
    }

    upgradeLight() {
        const cost = this.player.levels.light * 200;
        if (this.player.money >= cost) {
            this.player.money -= cost;
            this.player.lightRadius += 30;
            this.player.levels.light++;
            this.updateUi();
        }
    }

    upgradeReach() {
        const cost = this.player.levels.reach * 250;
        if (this.player.money >= cost) {
            this.player.money -= cost;
            this.player.miningRange += 14;
            this.player.levels.reach++;
            this.updateUi();
        }
    }

    upgradeSmelter() {
        const cost = this.player.levels.smelt * 400;
        if (this.player.money >= cost) {
            this.player.money -= cost;
            this.player.sellMultiplier = Math.min(3.0, this.player.sellMultiplier + 0.15);
            this.player.levels.smelt++;
            this.updateUi();
        }
    }

    upgradeLuck() {
        const cost = this.player.levels.luck * 500;
        if (this.player.money >= cost) {
            this.player.money -= cost;
            this.player.luck = Math.min(0.35, this.player.luck + 0.05);
            this.player.levels.luck++;
            this.updateUi();
        }
    }

    upgradeDrill() {
        const cost = this.player.levels.drill * 650;
        if (this.player.money >= cost) {
            this.player.money -= cost;
            this.player.miningInterval = Math.max(2, this.player.miningInterval - 1);
            this.player.levels.drill++;
            this.updateUi();
        }
    }
    
    update() {
        if (this.isForgeOpen) return;

        this.player.update(this.input, this.map);
        this.camera.follow(this.player);
        this.time += 1;

        this._updateShake();
        this.renderCamX = this.camera.x + this.shakeX;
        this.renderCamY = this.camera.y + this.shakeY;
        
        // Particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
            this.particles[i].update();
            if (this.particles[i].life <= 0) this.particles.splice(i, 1);
        }

        // Effects
        for (let i = this.effects.length - 1; i >= 0; i--) {
            this.effects[i].update();
            if (this.effects[i].life <= 0) this.effects.splice(i, 1);
        }

        // Floaters
        for (let i = this.floaters.length - 1; i >= 0; i--) {
            this.floaters[i].update();
            if (this.floaters[i].life <= 0) this.floaters.splice(i, 1);
        }
        
        // Mining Logic
        this.hoveredTile = null;
        const mouseEdgeDown = this.input.mouse.down && !this._mouseWasDown;
        this._mouseWasDown = this.input.mouse.down;
        if (this.input.mouse.down) {
            // Convert screen mouse to world mouse
            const mx = this.input.mouse.x + this.renderCamX;
            const my = this.input.mouse.y + this.renderCamY;
            
            const tx = Math.floor(mx / TILE_SIZE);
            const ty = Math.floor(my / TILE_SIZE);
            
            // Distance check (reach)
            const dx = (tx * TILE_SIZE + TILE_SIZE/2) - this.player.x;
            const dy = (ty * TILE_SIZE + TILE_SIZE/2) - this.player.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist < this.player.miningRange) { // Range
                this.hoveredTile = { tx, ty };
                if (this.placeDrillMode && mouseEdgeDown) {
                    this.tryPlaceDrill(tx, ty);
                } else if (!this.placeDrillMode) {
                    this.mineTile(tx, ty, mx, my);
                }
            }
        }

        // Drills
        for (const d of this.drills) d.update(this);
        
        // Forge Interaction Hint
        const forgeX = (this.map.forgeTile.x) * TILE_SIZE + TILE_SIZE/2;
        const forgeY = (this.map.forgeTile.y) * TILE_SIZE + TILE_SIZE/2;
        const distToForge = Math.sqrt((this.player.x - forgeX)**2 + (this.player.y - forgeY)**2);
        const msgArea = document.getElementById('message-area');
        const nearbyCache = this.findNearbyCache();
        if (this.placeDrillMode) {
            msgArea.textContent = `Place drill: click wall/ore (${this.player.drillRigs} left)`;
            msgArea.style.opacity = 1;
        } else if (nearbyCache) {
            msgArea.textContent = 'Tap or press E to open cache';
            msgArea.style.opacity = 1;
        } else if (distToForge < 100) {
            msgArea.textContent = 'Tap or press E to interact';
            msgArea.style.opacity = 1;
        } else {
            msgArea.style.opacity = 0;
        }

        if (this.uiDepth && this.time % 10 === 0) this.uiDepth.innerText = `${this.getDepth()}m`;

        this.audio.setForgeHum(distToForge < 160);

        this._autosaveTick++;
        if (this._autosaveTick % 120 === 0) this.saveProgress(); // ~ every 2s at 60fps
    }

    tryPlaceDrill(tx, ty) {
        if (this.player.drillRigs <= 0) return false;
        const tile = this.map.getTile(tx, ty);
        if (tile === T_FLOOR || tile === T_BEDROCK || tile === T_FORGE || tile === T_CACHE) return false;
        this.player.drillRigs--;
        this.placeDrillMode = false;
        this.drills.push(new DrillRig(tx, ty));
        const x = tx * TILE_SIZE + TILE_SIZE / 2;
        const y = ty * TILE_SIZE + TILE_SIZE / 2;
        this.effects.push(new Shockwave(x, y, 'rgba(255,176,32,0.95)', 28, 16));
        this.addShake(3);
        this.updateUi();
        this.saveProgress();
        return true;
    }

    _updateShake() {
        this.shakeMag *= 0.88;
        if (this.shakeMag < 0.05) {
            this.shakeMag = 0;
            this.shakeX = 0;
            this.shakeY = 0;
            return;
        }
        this.shakeX = (Math.random() - 0.5) * 2 * this.shakeMag;
        this.shakeY = (Math.random() - 0.5) * 2 * this.shakeMag;
    }

    addShake(amount) {
        this.shakeMag = Math.min(18, this.shakeMag + amount);
    }

    getDepth() {
        const ty = Math.floor(this.player.y / TILE_SIZE);
        return Math.max(0, ty - this.map.spawnTile.y);
    }

    findNearbyCache() {
        const ptx = Math.floor(this.player.x / TILE_SIZE);
        const pty = Math.floor(this.player.y / TILE_SIZE);
        for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
                const tx = ptx + dx;
                const ty = pty + dy;
                if (this.map.getTile(tx, ty) !== T_CACHE) continue;
                const cx = tx * TILE_SIZE + TILE_SIZE / 2;
                const cy = ty * TILE_SIZE + TILE_SIZE / 2;
                const dist = Math.hypot(this.player.x - cx, this.player.y - cy);
                if (dist < 70) return { tx, ty, dist };
            }
        }
        return null;
    }

    openCache(tx, ty) {
        if (this.map.getTile(tx, ty) !== T_CACHE) return;
        this.map.setTile(tx, ty, T_FLOOR);

        const x = tx * TILE_SIZE + TILE_SIZE / 2;
        const y = ty * TILE_SIZE + TILE_SIZE / 2;
        this.effects.push(new Shockwave(x, y, COLORS[T_CACHE], 44, 22));
        for (let i = 0; i < 18; i++) this.particles.push(new Particle(x, y, COLORS[T_CACHE], 4.2, 46));
        this.addShake(6);
        this.audio.playCacheOpen();

        const depth = this.getDepth();
        const tier = depth < 20 ? ['coal', 'iron'] :
            depth < 55 ? ['coal', 'iron', 'gold', 'diamond'] :
            depth < 90 ? ['iron', 'gold', 'diamond', 'emerald', 'ruby'] :
            ['gold', 'diamond', 'emerald', 'ruby', 'sapphire', 'amethyst'];

        const picks = 2 + (Math.random() < 0.35 ? 1 : 0);
        for (let i = 0; i < picks; i++) {
            const key = tier[Math.floor(Math.random() * tier.length)];
            this.player.inventory[key] += 1;
            this.spawnFloater(x - 18 + i * 10, y - 8 - i * 10, `+1 ${key.toUpperCase()}`, COLORS[this._tileForInvKey(key)] || COLORS[T_CACHE]);
        }
        const cash = 25 + Math.floor(Math.random() * (30 + depth * 2));
        this.player.money += cash;
        this.spawnFloater(x - 10, y - 34, `+$${cash}`, '#32d583');
        this.updateUi();
    }

    _tileForInvKey(key) {
        if (key === 'coal') return T_COAL;
        if (key === 'iron') return T_IRON;
        if (key === 'gold') return T_GOLD;
        if (key === 'diamond') return T_DIAMOND;
        if (key === 'emerald') return T_EMERALD;
        if (key === 'ruby') return T_RUBY;
        if (key === 'sapphire') return T_SAPPHIRE;
        if (key === 'amethyst') return T_AMETHYST;
        return T_CACHE;
    }
    
    mineTile(tx, ty, worldX, worldY) {
        const type = this.map.getTile(tx, ty);
        
        if (type !== T_FLOOR && type !== T_BEDROCK && type !== T_FORGE && type !== T_CACHE) {
            this.miningTick++;
            if (this.miningTick % this.player.miningInterval === 0) { // Visual shake or particle trigger frequency
                // Particles
                const c = COLORS[type] || '#fff';
                for (let i=0; i<4; i++) this.particles.push(new Particle(worldX, worldY, c, 2.4, 22));
                this.effects.push(new Shockwave(worldX, worldY, c, 18, 14));
                this.addShake(1.4);
                this.audio.playMineHit(type);
                this.player.pulseMine();
                
                // Damage
                const hp = this.map.getHp(tx, ty) - this.player.miningPower;
                this.map.setHp(tx, ty, hp);
                
                // Break
                if (hp <= 0) {
                    this.breakTile(tx, ty, type);
                }
            }
        }
    }
    
    breakTile(tx, ty, type) {
        this.map.setTile(tx, ty, T_FLOOR);
        
        // Big particles
        for (let i=0; i<10; i++) {
            this.particles.push(new Particle(
                tx*TILE_SIZE + TILE_SIZE/2, 
                ty*TILE_SIZE + TILE_SIZE/2, 
                COLORS[type], 4, 40
            ));
        }
        this.effects.push(new Shockwave(tx*TILE_SIZE + TILE_SIZE/2, ty*TILE_SIZE + TILE_SIZE/2, COLORS[type] || '#fff', 54, 22));
        this.addShake(5.5);
        this.audio.playMineBreak(type);
        
        // Loot
        let item = null;
        if (type === T_COAL) { this.player.inventory.coal++; item="Coal"; }
        if (type === T_IRON) { this.player.inventory.iron++; item="Iron"; }
        if (type === T_GOLD) { this.player.inventory.gold++; item="Gold"; }
        if (type === T_DIAMOND) { this.player.inventory.diamond++; item="Diamond"; }
        if (type === T_EMERALD) { this.player.inventory.emerald++; item="Emerald"; }
        if (type === T_RUBY) { this.player.inventory.ruby++; item="Ruby"; }
        if (type === T_SAPPHIRE) { this.player.inventory.sapphire++; item="Sapphire"; }
        if (type === T_AMETHYST) { this.player.inventory.amethyst++; item="Amethyst"; }
        
        if (item) {
            this.spawnFloater(tx*TILE_SIZE, ty*TILE_SIZE, `+1 ${item}`, COLORS[type]);
            const bonusChance = Math.min(0.18, this.player.luck * 0.35);
            if (bonusChance > 0 && Math.random() < bonusChance) {
                if (type === T_COAL) this.player.inventory.coal++;
                if (type === T_IRON) this.player.inventory.iron++;
                if (type === T_GOLD) this.player.inventory.gold++;
                if (type === T_DIAMOND) this.player.inventory.diamond++;
                if (type === T_EMERALD) this.player.inventory.emerald++;
                if (type === T_RUBY) this.player.inventory.ruby++;
                if (type === T_SAPPHIRE) this.player.inventory.sapphire++;
                if (type === T_AMETHYST) this.player.inventory.amethyst++;
                this.spawnFloater(tx*TILE_SIZE, ty*TILE_SIZE - 14, `BONUS +1`, COLORS[type]);
            }
            this.updateUi();
        }
    }
    
    spawnFloater(x, y, text, color) {
        this.floaters.push(new Floater(x, y, text, color));
    }
    
    updateUi() {
        document.getElementById('ui-money').innerText = this.player.money;
        document.getElementById('ui-drills').innerText = this.player.drillRigs;
        document.getElementById('ui-coal').innerText = this.player.inventory.coal;
        document.getElementById('ui-iron').innerText = this.player.inventory.iron;
        document.getElementById('ui-gold').innerText = this.player.inventory.gold;
        document.getElementById('ui-diamond').innerText = this.player.inventory.diamond;
        document.getElementById('ui-emerald').innerText = this.player.inventory.emerald;
        document.getElementById('ui-ruby').innerText = this.player.inventory.ruby;
        document.getElementById('ui-sapphire').innerText = this.player.inventory.sapphire;
        document.getElementById('ui-amethyst').innerText = this.player.inventory.amethyst;

        const sellPreview = this.getSellPreview();
        document.getElementById('ui-sell-preview').innerText = `$${sellPreview}`;
        document.getElementById('ui-money-menu').innerText = this.player.money;
        document.getElementById('ui-smelt-mult').innerText = `${this.player.sellMultiplier.toFixed(2)}×`;
        document.getElementById('ui-coal-menu').innerText = this.player.inventory.coal;
        document.getElementById('ui-iron-menu').innerText = this.player.inventory.iron;
        document.getElementById('ui-gold-menu').innerText = this.player.inventory.gold;
        document.getElementById('ui-diamond-menu').innerText = this.player.inventory.diamond;
        document.getElementById('ui-emerald-menu').innerText = this.player.inventory.emerald;
        document.getElementById('ui-ruby-menu').innerText = this.player.inventory.ruby;
        document.getElementById('ui-sapphire-menu').innerText = this.player.inventory.sapphire;
        document.getElementById('ui-amethyst-menu').innerText = this.player.inventory.amethyst;
        
        // Update Shop Costs
        document.getElementById('cost-pick').innerText = `$${this.player.levels.pick * 100}`;
        document.getElementById('cost-boots').innerText = `$${this.player.levels.boots * 150}`;
        document.getElementById('cost-light').innerText = `$${this.player.levels.light * 200}`;
        document.getElementById('cost-reach').innerText = `$${this.player.levels.reach * 250}`;
        document.getElementById('cost-smelt').innerText = `$${this.player.levels.smelt * 400}`;
        document.getElementById('cost-luck').innerText = `$${this.player.levels.luck * 500}`;
        document.getElementById('cost-drill').innerText = `$${this.player.levels.drill * 650}`;
        document.getElementById('cost-rig').innerText = `$${this.getDrillRigCost()}`;
        
        // Enable/Disable buttons
        document.getElementById('btn-upg-pick').disabled = this.player.money < this.player.levels.pick * 100;
        document.getElementById('btn-upg-boots').disabled = this.player.money < this.player.levels.boots * 150;
        document.getElementById('btn-upg-light').disabled = this.player.money < this.player.levels.light * 200;
        document.getElementById('btn-upg-reach').disabled = this.player.money < this.player.levels.reach * 250;
        document.getElementById('btn-upg-smelt').disabled = this.player.money < this.player.levels.smelt * 400;
        document.getElementById('btn-upg-luck').disabled = this.player.money < this.player.levels.luck * 500;
        document.getElementById('btn-upg-drill').disabled = this.player.money < this.player.levels.drill * 650;
        document.getElementById('btn-buy-rig').disabled = this.player.money < this.getDrillRigCost();
    }

    getSellPreview() {
        let total = 0;
        total += this.player.inventory.coal * ORE_VALUE.coal;
        total += this.player.inventory.iron * ORE_VALUE.iron;
        total += this.player.inventory.gold * ORE_VALUE.gold;
        total += this.player.inventory.diamond * ORE_VALUE.diamond;
        total += this.player.inventory.emerald * ORE_VALUE.emerald;
        total += this.player.inventory.ruby * ORE_VALUE.ruby;
        total += this.player.inventory.sapphire * ORE_VALUE.sapphire;
        total += this.player.inventory.amethyst * ORE_VALUE.amethyst;
        return Math.floor(total * this.player.sellMultiplier);
    }

    getSaveState() {
        const tx = Math.floor(this.player.x / TILE_SIZE);
        const ty = Math.floor(this.player.y / TILE_SIZE);
        const mapState = this.map.serializeNear(tx, ty, 12000);
        return {
            v: 1,
            ts: Date.now(),
            player: {
                x: this.player.x,
                y: this.player.y,
                money: this.player.money,
                inventory: this.player.inventory,
                drillRigs: this.player.drillRigs,
                miningPower: this.player.miningPower,
                lightRadius: this.player.lightRadius,
                maxSpeed: this.player.maxSpeed,
                miningRange: this.player.miningRange,
                miningInterval: this.player.miningInterval,
                sellMultiplier: this.player.sellMultiplier,
                luck: this.player.luck,
                levels: this.player.levels
            },
            map: mapState,
            drills: this.drills.map(d => ({ tx: d.tx, ty: d.ty }))
        };
    }

    applySaveState(state) {
        if (!state || state.v !== 1) return false;
        const p = state.player;
        if (p && Number.isFinite(p.x) && Number.isFinite(p.y)) {
            this.player.x = p.x;
            this.player.y = p.y;
            this.player.money = p.money || 0;
            this.player.inventory = p.inventory || this.player.inventory;
            this.player.drillRigs = p.drillRigs || 0;
            this.player.miningPower = p.miningPower || this.player.miningPower;
            this.player.lightRadius = p.lightRadius || this.player.lightRadius;
            this.player.maxSpeed = p.maxSpeed || this.player.maxSpeed;
            this.player.miningRange = p.miningRange || this.player.miningRange;
            this.player.miningInterval = p.miningInterval || this.player.miningInterval;
            this.player.sellMultiplier = p.sellMultiplier || this.player.sellMultiplier;
            this.player.luck = p.luck || this.player.luck;
            this.player.levels = p.levels || this.player.levels;
        }
        const m = state.map;
        if (m && Array.isArray(m.tiles) && Array.isArray(m.hp)) {
            this.map.modifiedTiles = new Map(m.tiles);
            this.map.modifiedHp = new Map(m.hp);
        }
        if (Array.isArray(state.drills)) {
            this.drills = state.drills
                .filter(d => Number.isFinite(d.tx) && Number.isFinite(d.ty))
                .map(d => new DrillRig(d.tx, d.ty));
        }
        this.updateUi();
        return true;
    }

    saveProgress() {
        SaveManager.save(this.getSaveState());
    }
    
    draw() {
        // Clear background
        ctx.fillStyle = ART.bg1;
        ctx.fillRect(0, 0, this.viewportWidth, this.viewportHeight);
        
        // Calculate Visible Range
        const startCol = Math.floor(this.camera.x / TILE_SIZE);
        const endCol = startCol + (this.viewportWidth / TILE_SIZE) + 2;
        const startRow = Math.floor(this.camera.y / TILE_SIZE);
        const endRow = startRow + (this.viewportHeight / TILE_SIZE) + 2;
        
        const camX = Math.floor(this.renderCamX);
        const camY = Math.floor(this.renderCamY);

        // Draw Map
        for (let y = startRow; y <= endRow; y++) {
            for (let x = startCol; x <= endCol; x++) {
                {
                    const tile = this.map.getTile(x, y);
                    const drawX = x * TILE_SIZE - camX;
                    const drawY = y * TILE_SIZE - camY;
                    
                    if (tile === T_FORGE) {
                        // Forge tile base
                        ctx.drawImage(this.tileArt.get(T_FLOOR, x, y), drawX, drawY);

                        // Forge body
                        ctx.save();
                        const glowPulse = 0.6 + 0.4 * Math.sin(this.time * 0.08);
                        ctx.shadowColor = ART.forgeHot;
                        ctx.shadowBlur = 22;
                        ctx.fillStyle = 'rgba(20,20,28,0.95)';
                        roundRectPath(ctx, drawX + 8, drawY + 10, TILE_SIZE - 16, TILE_SIZE - 14, 10);
                        ctx.fill();

                        // Mouth
                        const mg = ctx.createLinearGradient(0, drawY + 22, 0, drawY + TILE_SIZE - 8);
                        mg.addColorStop(0, `rgba(255,77,109,${0.10 + 0.18 * glowPulse})`);
                        mg.addColorStop(1, `rgba(255,176,32,${0.16 + 0.22 * glowPulse})`);
                        ctx.shadowBlur = 0;
                        ctx.fillStyle = mg;
                        roundRectPath(ctx, drawX + 14, drawY + 26, TILE_SIZE - 28, TILE_SIZE - 36, 8);
                        ctx.fill();

                        // Ember
                        ctx.shadowColor = ART.forgeHot;
                        ctx.shadowBlur = 26;
                        ctx.fillStyle = `rgba(255,176,32,${0.5 + 0.4 * glowPulse})`;
                        ctx.beginPath();
                        ctx.arc(drawX + TILE_SIZE / 2, drawY + TILE_SIZE - 18, 5 + 2 * glowPulse, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    } else {
                        const artType = (tile === T_BEDROCK) ? T_BEDROCK : tile;
                        ctx.drawImage(this.tileArt.get(artType, x, y), drawX, drawY);
                        
                        // Cracks based on HP
                        if (TILE_HP[tile]) {
                            const maxHp = TILE_HP[tile];
                            const currentHp = this.map.getHp(x, y);
                            const dmg = clamp01(1 - currentHp / maxHp);
                            if (dmg > 0.02) {
                                ctx.save();
                                ctx.globalAlpha = Math.min(0.85, dmg + 0.15);
                                ctx.strokeStyle = 'rgba(0,0,0,0.85)';
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.moveTo(drawX + 10, drawY + 10);
                                ctx.lineTo(drawX + 22, drawY + 26);
                                if (dmg > 0.45) {
                                    ctx.lineTo(drawX + 34, drawY + 14);
                                    ctx.moveTo(drawX + 18, drawY + 30);
                                    ctx.lineTo(drawX + 30, drawY + 36);
                                }
                                ctx.stroke();
                                ctx.restore();
                            }
                        }
                    }
                }
            }
        }

        // Mining highlight (visual only)
        if (this.hoveredTile) {
            const { tx, ty } = this.hoveredTile;
            {
                const tile = this.map.getTile(tx, ty);
                if (tile !== T_FLOOR && tile !== T_BEDROCK && tile !== T_FORGE && tile !== T_CACHE) {
                    const x0 = tx * TILE_SIZE - camX;
                    const y0 = ty * TILE_SIZE - camY;
                    const maxHp = TILE_HP[tile] || 1;
                    const hp = this.map.getHp(tx, ty) || maxHp;
                    const t = clamp01(1 - hp / maxHp);

                    ctx.save();
                    ctx.globalAlpha = 0.9;
                    ctx.shadowColor = COLORS[tile] || '#fff';
                    ctx.shadowBlur = 16;
                    ctx.strokeStyle = `rgba(255,255,255,${0.22 + 0.25 * t})`;
                    ctx.lineWidth = 2;
                    roundRectPath(ctx, x0 + 3, y0 + 3, TILE_SIZE - 6, TILE_SIZE - 6, 10);
                    ctx.stroke();
                    ctx.shadowBlur = 0;

                    // Progress arc
                    ctx.globalAlpha = 0.9;
                    ctx.strokeStyle = COLORS[tile] || '#fff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(x0 + TILE_SIZE / 2, y0 + TILE_SIZE / 2, 16, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * t);
                    ctx.stroke();
                    ctx.restore();
                }
            }
        }
        
        // Draw Player
        this.player.draw(ctx, camX, camY, this.time);

        // Drills
        for (const d of this.drills) d.draw(ctx, camX, camY, this.time);

        // Effects
        this.effects.forEach(e => e.draw(ctx, camX, camY));

        // Particles
        this.particles.forEach(p => p.draw(ctx, camX, camY));
        this.floaters.forEach(f => f.draw(ctx, camX, camY));
        
        // Lighting Mask
        // We draw a giant black rectangle over everything, then punch a hole in it
        
        // Create an offscreen canvas or just use a radial gradient
        // Since we are single file and performance matters, let's use a big radial gradient centered on player
        
        const screenPx = this.player.x - camX;
        const screenPy = this.player.y - camY;
        
        // Fill canvas with darkness
        const gradient = ctx.createRadialGradient(screenPx, screenPy, 30, screenPx, screenPy, this.player.lightRadius);
        gradient.addColorStop(0, 'rgba(0,0,0,0)');
        gradient.addColorStop(0.8, 'rgba(0,0,0,0.6)');
        gradient.addColorStop(1, 'rgba(0,0,0,0.98)'); // Very dark
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, this.viewportWidth, this.viewportHeight);

        // Vignette
        const vw = this.viewportWidth;
        const vh = this.viewportHeight;
        const vignette = ctx.createRadialGradient(vw / 2, vh / 2, Math.min(vw, vh) * 0.22, vw / 2, vh / 2, Math.max(vw, vh) * 0.78);
        vignette.addColorStop(0, 'rgba(0,0,0,0)');
        vignette.addColorStop(1, 'rgba(0,0,0,0.35)');
        ctx.fillStyle = vignette;
        ctx.fillRect(0, 0, vw, vh);

        // Film grain
        ctx.save();
        ctx.globalAlpha = 0.05;
        ctx.fillStyle = this._grainPattern;
        ctx.fillRect(0, 0, vw, vh);
        ctx.restore();

        this.drawForgeCompass();
    }

    drawForgeCompass() {
        const forgeX = (this.map.forgeTile.x) * TILE_SIZE + TILE_SIZE / 2;
        const forgeY = (this.map.forgeTile.y) * TILE_SIZE + TILE_SIZE / 2;
        const vx = forgeX - this.player.x;
        const vy = forgeY - this.player.y;
        const dist = Math.hypot(vx, vy);
        if (dist < 140) return;

        const angle = Math.atan2(vy, vx);
        const x = this.viewportWidth - 56;
        const y = 66;

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.globalAlpha = 0.92;
        ctx.shadowColor = ART.forgeHot;
        ctx.shadowBlur = 16;
        ctx.fillStyle = 'rgba(255,77,109,0.95)';
        ctx.beginPath();
        ctx.moveTo(16, 0);
        ctx.lineTo(-10, -9);
        ctx.lineTo(-6, 0);
        ctx.lineTo(-10, 9);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 0.75;
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.beginPath();
        ctx.moveTo(10, 0);
        ctx.lineTo(-2, -4);
        ctx.lineTo(-2, 4);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }
}

// --- Init ---

function interactAction() {
    if (!game) return;
    game.audio.ensure();
    game.interact();
}

function loop() {
    if (!gameRunning) return;
    
    game.update();
    game.draw();
    
    requestAnimationFrame(loop);
}

window.addEventListener('resize', () => {
    if (game) game.resize();
});

window.addEventListener('beforeunload', () => {
    if (game) game.saveProgress();
});

function startGame({ newMine }) {
    document.getElementById('intro-modal').style.display = 'none';
    if (newMine) SaveManager.clear();
    const save = (!newMine) ? SaveManager.load() : null;
    game = new Game();
    game.audio.ensure();
    if (save) game.applySaveState(save);
    gameRunning = true;
    requestAnimationFrame(loop);
}

function syncIntroSaveUi() {
    const btn = document.getElementById('btn-continue');
    const hint = document.getElementById('save-hint');
    const has = SaveManager.hasSave();
    if (btn) btn.style.display = has ? 'block' : 'none';
    if (hint) hint.style.display = has ? 'block' : 'none';
}

syncIntroSaveUi();

function restartMine() {
    SaveManager.clear();
    window.location.reload();
}

</script>
</body>
</html>
